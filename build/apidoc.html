<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://automattic.github.io/kue/"

    >kue (v0.11.5)</a>
</h1>
<h4>Feature rich priority job queue backed by redis</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue">module kue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue">
            function <span class="apidocSignatureSpan"></span>kue
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job">
            function <span class="apidocSignatureSpan">kue.</span>Job
            <span class="apidocSignatureSpan">( type, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.createQueue">
            function <span class="apidocSignatureSpan">kue.</span>createQueue
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker">
            function <span class="apidocSignatureSpan">kue.</span>worker
            <span class="apidocSignatureSpan">( queue, type )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>Job.client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>Job.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>kue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>kue.prototype.testMode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>redis</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>redis._pubsub</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>singleton</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>worker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.</span>workers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.Job">module kue.Job</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.</span>disableSearch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.</span>jobEvents</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.Job">
            function <span class="apidocSignatureSpan">kue.</span>Job
            <span class="apidocSignatureSpan">( type, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.get">
            function <span class="apidocSignatureSpan">kue.Job.</span>get
            <span class="apidocSignatureSpan">( id, jobType, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.log">
            function <span class="apidocSignatureSpan">kue.Job.</span>log
            <span class="apidocSignatureSpan">( id, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.range">
            function <span class="apidocSignatureSpan">kue.Job.</span>range
            <span class="apidocSignatureSpan">( from, to, order, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.rangeByState">
            function <span class="apidocSignatureSpan">kue.Job.</span>rangeByState
            <span class="apidocSignatureSpan">( state, from, to, order, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.rangeByType">
            function <span class="apidocSignatureSpan">kue.Job.</span>rangeByType
            <span class="apidocSignatureSpan">( type, state, from, to, order, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.remove">
            function <span class="apidocSignatureSpan">kue.Job.</span>remove
            <span class="apidocSignatureSpan">( id, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.removeBadJob">
            function <span class="apidocSignatureSpan">kue.Job.</span>removeBadJob
            <span class="apidocSignatureSpan">( id, jobType)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.</span>priorities</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.Job.client">module kue.Job.client</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>buffers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>closing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>connected</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>enable_offline_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>fire_strings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>message_buffers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>monitoring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>pipeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>ready</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.Job.client.</span>should_buffer</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.client.createFIFO">
            function <span class="apidocSignatureSpan">kue.Job.client.</span>createFIFO
            <span class="apidocSignatureSpan">( id )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.client.getKey">
            function <span class="apidocSignatureSpan">kue.Job.client.</span>getKey
            <span class="apidocSignatureSpan">( key )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.client.stripFIFO">
            function <span class="apidocSignatureSpan">kue.Job.client.</span>stripFIFO
            <span class="apidocSignatureSpan">( zid )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>attempts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>connect_timeout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>connection_id</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>max_attempts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>pub_sub_mode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>retry_backoff</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>retry_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>retry_totaltime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>sub_commands_left</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.Job.client.</span>times_connected</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>command_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>connection_options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>offline_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>old_state</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>pipeline_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>reply_parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>retry_max_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>retry_timer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>server_info</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>stream</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.Job.client.</span>subscription_set</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.Job.client.</span>address</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.Job.client.</span>prefix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.Job.client.</span>reply</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.Job.prototype">module kue.Job.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype._getBackoffImpl">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>_getBackoffImpl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.active">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>active
            <span class="apidocSignatureSpan">( clbk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.attempt">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>attempt
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.attempts">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>attempts
            <span class="apidocSignatureSpan">( n )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.backoff">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>backoff
            <span class="apidocSignatureSpan">( param )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.complete">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>complete
            <span class="apidocSignatureSpan">( clbk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.delay">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>delay
            <span class="apidocSignatureSpan">( ms )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.delayed">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>delayed
            <span class="apidocSignatureSpan">( clbk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.error">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>error
            <span class="apidocSignatureSpan">( err )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.events">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>events
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.failed">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>failed
            <span class="apidocSignatureSpan">( clbk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.failedAttempt">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>failedAttempt
            <span class="apidocSignatureSpan">( theErr, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.get">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>get
            <span class="apidocSignatureSpan">( key, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.inactive">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>inactive
            <span class="apidocSignatureSpan">( clbk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.log">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>log
            <span class="apidocSignatureSpan">( str )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.priority">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>priority
            <span class="apidocSignatureSpan">( level )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.progress">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>progress
            <span class="apidocSignatureSpan">( complete, total, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.reattempt">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>reattempt
            <span class="apidocSignatureSpan">( attempts, clbk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.refreshTtl">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>refreshTtl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.remove">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>remove
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.removeOnComplete">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>removeOnComplete
            <span class="apidocSignatureSpan">( param )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.save">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>save
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.searchKeys">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>searchKeys
            <span class="apidocSignatureSpan">( keys )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.set">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>set
            <span class="apidocSignatureSpan">( key, val, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.state">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>state
            <span class="apidocSignatureSpan">( state, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.subscribe">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>subscribe
            <span class="apidocSignatureSpan">( callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.toJSON">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.ttl">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>ttl
            <span class="apidocSignatureSpan">( param )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.Job.prototype.update">
            function <span class="apidocSignatureSpan">kue.Job.prototype.</span>update
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.events">module kue.events</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.events.</span>subscribeStarted</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.events.add">
            function <span class="apidocSignatureSpan">kue.events.</span>add
            <span class="apidocSignatureSpan">( job, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.events.emit">
            function <span class="apidocSignatureSpan">kue.events.</span>emit
            <span class="apidocSignatureSpan">( id, event )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.events.onMessage">
            function <span class="apidocSignatureSpan">kue.events.</span>onMessage
            <span class="apidocSignatureSpan">( channel, msg )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.events.remove">
            function <span class="apidocSignatureSpan">kue.events.</span>remove
            <span class="apidocSignatureSpan">( job )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.events.subscribe">
            function <span class="apidocSignatureSpan">kue.events.</span>subscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.events.unsubscribe">
            function <span class="apidocSignatureSpan">kue.events.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.events.</span>callbackQueue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.events.</span>jobs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.events.</span>queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.events.</span>key</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.json">module kue.json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.createJob">
            function <span class="apidocSignatureSpan">kue.json.</span>createJob
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.inactive">
            function <span class="apidocSignatureSpan">kue.json.</span>inactive
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.job">
            function <span class="apidocSignatureSpan">kue.json.</span>job
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.jobRange">
            function <span class="apidocSignatureSpan">kue.json.</span>jobRange
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.jobStateRange">
            function <span class="apidocSignatureSpan">kue.json.</span>jobStateRange
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.jobTypeRange">
            function <span class="apidocSignatureSpan">kue.json.</span>jobTypeRange
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.jobTypeStateStats">
            function <span class="apidocSignatureSpan">kue.json.</span>jobTypeStateStats
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.log">
            function <span class="apidocSignatureSpan">kue.json.</span>log
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.remove">
            function <span class="apidocSignatureSpan">kue.json.</span>remove
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.search">
            function <span class="apidocSignatureSpan">kue.json.</span>search
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.stats">
            function <span class="apidocSignatureSpan">kue.json.</span>stats
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.types">
            function <span class="apidocSignatureSpan">kue.json.</span>types
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.updatePriority">
            function <span class="apidocSignatureSpan">kue.json.</span>updatePriority
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.json.updateState">
            function <span class="apidocSignatureSpan">kue.json.</span>updateState
            <span class="apidocSignatureSpan">( req, res )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.kue">module kue.kue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.kue">
            function <span class="apidocSignatureSpan">kue.</span>kue
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.Job">
            function <span class="apidocSignatureSpan">kue.kue.</span>Job
            <span class="apidocSignatureSpan">( type, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.createQueue">
            function <span class="apidocSignatureSpan">kue.kue.</span>createQueue
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.kue.</span>redis</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.kue.</span>singleton</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.kue.</span>workers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.kue.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.kue.prototype">module kue.kue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.active">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>active
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.activeCount">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>activeCount
            <span class="apidocSignatureSpan">( type, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.card">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>card
            <span class="apidocSignatureSpan">( state, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.cardByType">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>cardByType
            <span class="apidocSignatureSpan">( type, state, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.checkActiveJobTtl">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>checkActiveJobTtl
            <span class="apidocSignatureSpan">( ttlOptions )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.checkJobPromotion">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>checkJobPromotion
            <span class="apidocSignatureSpan">( promotionOptions )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.complete">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>complete
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.completeCount">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>completeCount
            <span class="apidocSignatureSpan">( type, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.create">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>create
            <span class="apidocSignatureSpan">( type, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.createJob">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>createJob
            <span class="apidocSignatureSpan">( type, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.delayed">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>delayed
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.delayedCount">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>delayedCount
            <span class="apidocSignatureSpan">( type, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.failed">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>failed
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.failedCount">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>failedCount
            <span class="apidocSignatureSpan">( type, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.inactive">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>inactive
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.inactiveCount">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>inactiveCount
            <span class="apidocSignatureSpan">( type, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.on">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>on
            <span class="apidocSignatureSpan">( event )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.process">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>process
            <span class="apidocSignatureSpan">( type, n, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.promote">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>promote
            <span class="apidocSignatureSpan">( ms, l )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.setting">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>setting
            <span class="apidocSignatureSpan">( name, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.setupTimers">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>setupTimers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.shutdown">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>shutdown
            <span class="apidocSignatureSpan">( timeout, type, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.state">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>state
            <span class="apidocSignatureSpan">( state, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.types">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>types
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.watchStuckJobs">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>watchStuckJobs
            <span class="apidocSignatureSpan">( ms )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.workTime">
            function <span class="apidocSignatureSpan">kue.kue.prototype.</span>workTime
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.kue.prototype.</span>testMode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.kue.prototype.testMode">module kue.kue.prototype.testMode</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>processQueue</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.testMode.clear">
            function <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.testMode.enter">
            function <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>enter
            <span class="apidocSignatureSpan">(process)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.kue.prototype.testMode.exit">
            function <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>jobs</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.redis">module kue.redis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis.client">
            function <span class="apidocSignatureSpan">kue.redis.</span>client
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis.configureFactory">
            function <span class="apidocSignatureSpan">kue.redis.</span>configureFactory
            <span class="apidocSignatureSpan">( options, queue )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis.createClient">
            function <span class="apidocSignatureSpan">kue.redis.</span>createClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis.createClientFactory">
            function <span class="apidocSignatureSpan">kue.redis.</span>createClientFactory
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis.pubsubClient">
            function <span class="apidocSignatureSpan">kue.redis.</span>pubsubClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis.reset">
            function <span class="apidocSignatureSpan">kue.redis.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis.</span>_client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis.</span>_pubsub</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.redis._pubsub">module kue.redis._pubsub</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>buffers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>closing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>connected</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>enable_offline_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>fire_strings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>message_buffers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>monitoring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>pipeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>ready</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">kue.redis._pubsub.</span>should_buffer</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis._pubsub.createFIFO">
            function <span class="apidocSignatureSpan">kue.redis._pubsub.</span>createFIFO
            <span class="apidocSignatureSpan">( id )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis._pubsub.getKey">
            function <span class="apidocSignatureSpan">kue.redis._pubsub.</span>getKey
            <span class="apidocSignatureSpan">( key )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.redis._pubsub.stripFIFO">
            function <span class="apidocSignatureSpan">kue.redis._pubsub.</span>stripFIFO
            <span class="apidocSignatureSpan">( zid )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>attempts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>connect_timeout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>connection_id</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>max_attempts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>pub_sub_mode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>retry_backoff</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>retry_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>retry_totaltime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>sub_commands_left</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kue.redis._pubsub.</span>times_connected</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>command_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>connection_options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>offline_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>old_state</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>pipeline_queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>reply_parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>retry_max_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>retry_timer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>server_info</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>stream</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.redis._pubsub.</span>subscription_set</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.redis._pubsub.</span>address</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.redis._pubsub.</span>prefix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kue.redis._pubsub.</span>reply</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.worker">module kue.worker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.worker">
            function <span class="apidocSignatureSpan">kue.</span>worker
            <span class="apidocSignatureSpan">( queue, type )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kue.worker.</span>client</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kue.worker.prototype">module kue.worker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.emitJobEvent">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>emitJobEvent
            <span class="apidocSignatureSpan">( event, job, arg1, arg2 )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.error">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>error
            <span class="apidocSignatureSpan">( err, job )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.failed">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>failed
            <span class="apidocSignatureSpan">( job, theErr, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.getJob">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>getJob
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.idle">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>idle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.process">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>process
            <span class="apidocSignatureSpan">( job, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.resume">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.shutdown">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>shutdown
            <span class="apidocSignatureSpan">( timeout, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.start">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>start
            <span class="apidocSignatureSpan">( fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kue.worker.prototype.zpop">
            function <span class="apidocSignatureSpan">kue.worker.prototype.</span>zpop
            <span class="apidocSignatureSpan">( key, fn )</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue" id="apidoc.module.kue">module kue</a></h1>


    <h2>
        <a href="#apidoc.element.kue.kue" id="apidoc.element.kue.kue">
        function <span class="apidocSignatureSpan"></span>kue
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue( options ) {
  options     = options || {};
  this.name   = options.name || &#x27;kue&#x27;;
  this.id = [ &#x27;kue&#x27;, require(&#x27;os&#x27;).hostname(), process.pid ].join(&#x27;:&#x27;);
  this._options   = options;
  this.promoter     = null;
  this.workers      = exports.workers;
  this.shuttingDown = false;
  Job.disableSearch = options.disableSearch !== false;
  options.jobEvents !== undefined ? Job.jobEvents = options.jobEvents : &#x27;&#x27;;
  redis.configureFactory(options, this);
  this.client = Worker.client = Job.client = redis.createClient();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job" id="apidoc.element.kue.Job">
        function <span class="apidocSignatureSpan">kue.</span>Job
        <span class="apidocSignatureSpan">( type, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Job( type, data ) {
  this.type          = type;
  this.data          = data || {};
  this._max_attempts = 1;
  this._jobEvents = exports.jobEvents;
//  this.client = redis.client();
  this.client = Job.client/* || (Job.client = redis.client())*/;
  this.priority(&#x27;normal&#x27;);
  this.on(&#x27;error&#x27;, function( err ) {
  });// prevent uncaught exceptions on failed job errors
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.createQueue" id="apidoc.element.kue.createQueue">
        function <span class="apidocSignatureSpan">kue.</span>createQueue
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createQueue = function ( options ) {
  if( !Queue.singleton ) {
    Queue.singleton = new Queue(options);
  }
  events.subscribe();
  return Queue.singleton;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  - [Screencasts](#screencasts)
  - [License](#license)



## Creating Jobs

First create a job `Queue` with `kue.<span class="apidocCodeKeywordSpan">createQueue</span>()`:

```js
var kue = require(&#x27;kue&#x27;)
  , queue = kue.createQueue();
```

Calling `queue.create()` with the type of job (&#x22;email&#x22;), and arbitrary job data will return a `Job`, which can then be
 `save()`ed, adding it to redis, with a default priority level of &#x22;normal&#x22;. The `save()` method optionally accepts a callback
, responding with an `error` if something goes wrong. The `title` key is special-cased, and will display in the job listings within
 the UI, making it easier to find a specific job.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker" id="apidoc.element.kue.worker">
        function <span class="apidocSignatureSpan">kue.</span>worker
        <span class="apidocSignatureSpan">( queue, type )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Worker( queue, type ) {
  this.queue   = queue;
  this.type    = type;
  this.client  = Worker.client || (Worker.client = redis.createClient());
  this.running = true;
  this.job     = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.Job" id="apidoc.module.kue.Job">module kue.Job</a></h1>






    <h2>
        <a href="#apidoc.element.kue.Job.Job" id="apidoc.element.kue.Job.Job">
        function <span class="apidocSignatureSpan">kue.</span>Job
        <span class="apidocSignatureSpan">( type, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Job( type, data ) {
  this.type          = type;
  this.data          = data || {};
  this._max_attempts = 1;
  this._jobEvents = exports.jobEvents;
//  this.client = redis.client();
  this.client = Job.client/* || (Job.client = redis.client())*/;
  this.priority(&#x27;normal&#x27;);
  this.on(&#x27;error&#x27;, function( err ) {
  });// prevent uncaught exceptions on failed job errors
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.get" id="apidoc.element.kue.Job.get">
        function <span class="apidocSignatureSpan">kue.Job.</span>get
        <span class="apidocSignatureSpan">( id, jobType, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function ( id, jobType, fn ) {
  if (typeof jobType === &#x27;function&#x27; &#x26;&#x26; !fn) {
    fn = jobType;
    jobType = &#x27;&#x27;;
  }
  var client = redis.client()
    , job    = new Job;

  job.id = id;
  job.zid = client.createFIFO(id);
  client.hgetall(client.getKey(&#x27;job:&#x27; + job.id), function( err, hash ) {
    if( err ) return fn(err);
    if( !hash ) {
      exports.removeBadJob(job.id, jobType);
      return fn(new Error(&#x27;job &#x22;&#x27; + job.id + &#x27;&#x22; doesnt exist&#x27;));
    }
    if( !hash.type ) {
      exports.removeBadJob(job.id, jobType);
      return fn(new Error(&#x27;job &#x22;&#x27; + job.id + &#x27;&#x22; is invalid&#x27;))
    }
    // TODO: really lame, change some methods so
    // we can just merge these
    job.type              = hash.type;
    job._ttl              = hash.ttl;
    job._delay            = hash.delay;
    job.priority(Number(hash.priority));
    job._progress         = hash.progress;
    job._attempts         = Number(hash.attempts);
    job._max_attempts     = Number(hash.max_attempts);
    job._state            = hash.state;
    job._error            = hash.error;
    job.created_at        = hash.created_at;
    job.promote_at        = hash.promote_at;
    job.updated_at        = hash.updated_at;
    job.failed_at         = hash.failed_at;
    job.started_at        = hash.started_at;
    job.duration          = hash.duration;
    job.workerId          = hash.workerId;
    job._removeOnComplete = hash.removeOnComplete;
    try {
      if( hash.data ) job.data = JSON.parse(hash.data);
      if( hash.result ) job.result = JSON.parse(hash.result);
      if( hash.progress_data ) job.progress_data = JSON.parse(hash.progress_data);
      if( hash.backoff ) {
        var source = &#x27;job._backoff = &#x27; + hash.backoff + &#x27;;&#x27;;
//                require(&#x27;vm&#x27;).runInContext( source );
        eval(source);
      }
    } catch(e) {
      err = e;
    }
    fn(err, job);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Queue-level events provide access to the job-level events previously mentioned, however scoped to the `Queue` instance to apply
logic at a &#x22;global&#x22; level. An example of this is removing completed jobs:

```js
queue.on(&#x27;job enqueue&#x27;, function(id, type){
  console.log( &#x27;Job %s got queued of type %s&#x27;, id, type );

}).on(&#x27;job complete&#x27;, function(id, result){
  kue.Job.<span class="apidocCodeKeywordSpan">get</span>(id, function(err, job){
    if (err) return;
    job.remove(function(err){
      if (err) throw err;
      console.log(&#x27;removed completed job #%d&#x27;, job.id);
    });
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.log" id="apidoc.element.kue.Job.log">
        function <span class="apidocSignatureSpan">kue.Job.</span>log
        <span class="apidocSignatureSpan">( id, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function ( id, fn ) {
<span class="apidocCodeCommentSpan">  /*redis*/
</span>  Job.client/*()*/.lrange(Job.client.getKey(&#x27;job:&#x27; + id + &#x27;:log&#x27;), 0, -1, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var job = queue.create(&#x27;email&#x27;, {
    title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).save( function(err){
   if( !err ) console.<span class="apidocCodeKeywordSpan">log</span>( job.id );
});
```

### Job Priority

To specify the priority of a job, simply invoke the `priority()` method with a number, or priority name, which is mapped to a number
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.range" id="apidoc.element.kue.Job.range">
        function <span class="apidocSignatureSpan">kue.Job.</span>range
        <span class="apidocSignatureSpan">( from, to, order, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function ( from, to, order, fn ) {
  redis.client().zrange(redis.client().getKey(&#x27;jobs&#x27;), from, to, get(fn, order));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

exports.jobRange = function( req, res ) {
 var from  = parseInt(req.params.from, 10)
   , to    = parseInt(req.params.to, 10)
   , order = req.params.order;

 Job.<span class="apidocCodeKeywordSpan">range</span>(from, to, order, function( err, jobs ) {
   if( err ) return res.json({ error: err.message });
   res.json(jobs);
 });
};

/**
* Get jobs by :state, and range :from..:to.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.rangeByState" id="apidoc.element.kue.Job.rangeByState">
        function <span class="apidocSignatureSpan">kue.Job.</span>rangeByState
        <span class="apidocSignatureSpan">( state, from, to, order, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rangeByState = function ( state, from, to, order, fn ) {
  redis.client().zrange(redis.client().getKey(&#x27;jobs:&#x27; + state), from, to, get(fn, order));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // you may want to fetch each id to get the Job object out of it...
});
```

however the second one doesn&#x27;t scale to large deployments, there you can use more specific `Job` static methods:

```js
kue.Job.<span class="apidocCodeKeywordSpan">rangeByState</span>( &#x27;failed&#x27;, 0, n, &#x27;asc&#x27;, function( err, jobs ) {
  // you have an array of maximum n Job objects here
});
```
or

```js
kue.Job.rangeByType( &#x27;my-job-type&#x27;, &#x27;failed&#x27;, 0, n, &#x27;asc&#x27;, function( err, jobs ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.rangeByType" id="apidoc.element.kue.Job.rangeByType">
        function <span class="apidocSignatureSpan">kue.Job.</span>rangeByType
        <span class="apidocSignatureSpan">( type, state, from, to, order, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rangeByType = function ( type, state, from, to, order, fn ) {
  redis.client().zrange(redis.client().getKey(&#x27;jobs:&#x27; + type + &#x27;:&#x27; + state), from, to, get(fn, order, type));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
kue.Job.rangeByState( &#x27;failed&#x27;, 0, n, &#x27;asc&#x27;, function( err, jobs ) {
  // you have an array of maximum n Job objects here
});
```
or

```js
kue.Job.<span class="apidocCodeKeywordSpan">rangeByType</span>( &#x27;my-job-type&#x27;, &#x27;failed&#x27;, 0, n, &#x27;asc&#x27
;, function( err, jobs ) {
  // you have an array of maximum n Job objects here
});
```

**Note** *that the last two methods are subject to change in later Kue versions.*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.remove" id="apidoc.element.kue.Job.remove">
        function <span class="apidocSignatureSpan">kue.Job.</span>remove
        <span class="apidocSignatureSpan">( id, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function ( id, fn ) {
  fn = fn || noop;
  exports.get(id, function( err, job ) {
    if( err ) return fn(err);
    if( !job ) return fn(new Error(&#x27;failed to find job &#x27; + id));
    job.remove(fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
queue.on(&#x27;job enqueue&#x27;, function(id, type){
  console.log( &#x27;Job %s got queued of type %s&#x27;, id, type );

}).on(&#x27;job complete&#x27;, function(id, result){
  kue.Job.get(id, function(err, job){
    if (err) return;
    job.<span class="apidocCodeKeywordSpan">remove</span>(function(err){
      if (err) throw err;
      console.log(&#x27;removed completed job #%d&#x27;, job.id);
    });
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.removeBadJob" id="apidoc.element.kue.Job.removeBadJob">
        function <span class="apidocSignatureSpan">kue.Job.</span>removeBadJob
        <span class="apidocSignatureSpan">( id, jobType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeBadJob = function ( id, jobType) {
  var client = redis.client();
  var zid = client.createFIFO(id);
  client.multi()
    .del(client.getKey(&#x27;job:&#x27; + id + &#x27;:log&#x27;))
    .del(client.getKey(&#x27;job:&#x27; + id))
    .zrem(client.getKey(&#x27;jobs:inactive&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:active&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:complete&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:failed&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:delayed&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:&#x27; + jobType + &#x27;:inactive&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:&#x27; + jobType+ &#x27;:active&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:&#x27; + jobType + &#x27;:complete&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:&#x27; + jobType + &#x27;:failed&#x27;), zid)
    .zrem(client.getKey(&#x27;jobs:&#x27; + jobType + &#x27;:delayed&#x27;), zid)
    .exec();
  if( !exports.disableSearch ) {
    getSearch().remove(id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , job    = new Job;

job.id = id;
job.zid = client.createFIFO(id);
client.hgetall(client.getKey(&#x27;job:&#x27; + job.id), function( err, hash ) {
  if( err ) return fn(err);
  if( !hash ) {
    exports.<span class="apidocCodeKeywordSpan">removeBadJob</span>(job.id, jobType);
    return fn(new Error(&#x27;job &#x22;&#x27; + job.id + &#x27;&#x22; doesnt exist&#x27;));
  }
  if( !hash.type ) {
    exports.removeBadJob(job.id, jobType);
    return fn(new Error(&#x27;job &#x22;&#x27; + job.id + &#x27;&#x22; is invalid&#x27;))
  }
  // TODO: really lame, change some methods so
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.Job.client" id="apidoc.module.kue.Job.client">module kue.Job.client</a></h1>






















    <h2>
        <a href="#apidoc.element.kue.Job.client.createFIFO" id="apidoc.element.kue.Job.client.createFIFO">
        function <span class="apidocSignatureSpan">kue.Job.client.</span>createFIFO
        <span class="apidocSignatureSpan">( id )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFIFO = function ( id ) {
  //Create an id for the zset to preserve FIFO order
  var idLen = &#x27;&#x27; + id.toString().length;
  var len = 2 - idLen.length;
  while (len--) idLen = &#x27;0&#x27; + idLen;
  return idLen + &#x27;|&#x27; + id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if( !pending ) return fn(null, ids);
ids.forEach(function( id ) {
  id = redis.client().stripFIFO(id); // turn zid back to regular job id
  exports.get(id, jobType, function( err, job ) {
    if( err ) {
      console.error(err);
    } else {
      jobs[ redis.client().<span class="apidocCodeKeywordSpan">createFIFO</span>(job.id) ] = job;
    }
    --pending || fn(null, &#x27;desc&#x27; == order
      ? map(jobs, ids).reverse()
      : map(jobs, ids));

  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.client.getKey" id="apidoc.element.kue.Job.client.getKey">
        function <span class="apidocSignatureSpan">kue.Job.client.</span>getKey
        <span class="apidocSignatureSpan">( key )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKey = function ( key ) {
  if( client.constructor.name == &#x27;Redis&#x27;  || client.constructor.name == &#x27;Cluster&#x27;) {
    // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node
    // otherwise multi commands fail, since they use ioredis&#x27;s pipeline.
    return &#x27;{&#x27; + this.prefix + &#x27;}:&#x27; + key;
  }
  return this.prefix + &#x27;:&#x27; + key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if( err ) {
  // Something went wrong and we weren&#x27;t able to set a lock
  self.emit(&#x27;error&#x27;, err);
  return;
}
if( typeof unlock === &#x27;function&#x27; ) {
  // If the lock is set successfully by this process, an unlock function is passed to our callback.
  client.zrangebyscore(client.<span class="apidocCodeKeywordSpan">getKey</span>(&#x27;jobs:delayed&#x27;), 0, Date.now(), &#x27;
LIMIT&#x27;, 0, limit, function( err, ids ) {
    if( err || !ids.length ) return unlock();
    //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1
    var doUnlock = _.after(ids.length, unlock);
    ids.forEach(function( id ) {
      id = client.stripFIFO(id);
      Job.get(id, function( err, job ) {
        if( err ) return doUnlock();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.client.stripFIFO" id="apidoc.element.kue.Job.client.stripFIFO">
        function <span class="apidocSignatureSpan">kue.Job.client.</span>stripFIFO
        <span class="apidocSignatureSpan">( zid )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripFIFO = function ( zid ) {
  if ( typeof zid === &#x27;string&#x27; ) {
    return +zid.substr(zid.indexOf(&#x27;|&#x27;)+1);
  } else {
    // Sometimes this gets called with an undefined
    // it seems to be OK to have that not resolve to an id
    return zid;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if( typeof unlock === &#x27;function&#x27; ) {
// If the lock is set successfully by this process, an unlock function is passed to our callback.
client.zrangebyscore(client.getKey(&#x27;jobs:delayed&#x27;), 0, Date.now(), &#x27;LIMIT&#x27;, 0, limit, function( err, ids ) {
  if( err || !ids.length ) return unlock();
  //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1
  var doUnlock = _.after(ids.length, unlock);
  ids.forEach(function( id ) {
    id = client.<span class="apidocCodeKeywordSpan">stripFIFO</span>(id);
    Job.get(id, function( err, job ) {
      if( err ) return doUnlock();
      events.emit(id, &#x27;promotion&#x27;);
      job.inactive(doUnlock);
    });
  });
});
...</pre></li>
    </ul>


























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.Job.prototype" id="apidoc.module.kue.Job.prototype">module kue.Job.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kue.Job.prototype._getBackoffImpl" id="apidoc.element.kue.Job.prototype._getBackoffImpl">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>_getBackoffImpl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getBackoffImpl = function () {
  var supported_backoffs = {
    fixed: function( delay ) {
      return function( attempts ) {
        return delay;
      };
    }
    , exponential: function( delay ) {
      return function( attempts ) {
        return Math.round(delay * 0.5 * ( Math.pow(2, attempts) - 1));
      };
    }
  };
  if( _.isPlainObject(this._backoff) ) {
    return supported_backoffs[ this._backoff.type ](this._backoff.delay || this._delay);
  } else {
    return this._backoff;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param clbk
 */

Job.prototype.reattempt = function( attempts, clbk ) {
clbk = clbk || noop;
if( this.backoff() ) {
  var delay = this.delay();
  if( _.isFunction(this.<span class="apidocCodeKeywordSpan">_getBackoffImpl</span>()) ) {
    try {
      delay = this._getBackoffImpl().apply(this, [ attempts ]);
    } catch(e) {
      clbk(e);
    }
  }
  var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.active" id="apidoc.element.kue.Job.prototype.active">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>active
        <span class="apidocSignatureSpan">( clbk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">active = function ( clbk ) {
  return this.state(&#x27;active&#x27;, clbk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


### Programmatic Job Management

If you did none of above in [Error Handling](#error-handling) section or your process lost active jobs in any way, you can recover
 from them when your process is restarted. A blind logic would be to re-queue all stuck jobs:

```js
queue.<span class="apidocCodeKeywordSpan">active</span>( function( err, ids ) {
  ids.forEach( function( id ) {
    kue.Job.get( id, function( err, job ) {
      // Your application should check if job is a stuck one
      job.inactive();
    });
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.attempt" id="apidoc.element.kue.Job.prototype.attempt">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>attempt
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attempt = function ( fn ) {
  var client = this.client
    , id     = this.id
    , key    = client.getKey(&#x27;job:&#x27; + id);

  this._attempts = this._attempts || 0;
  if( this._attempts &#x3c; this._max_attempts ) {
    client.hincrby(key, &#x27;attempts&#x27;, 1, function( err, attempts ) {
      this._attempts = attempts;
      fn(err, Math.max(0, this._max_attempts - attempts), attempts, this._max_attempts);
    }.bind(this));
  } else {
    fn(null, 0, this._attempts, this._max_attempts);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._max_attempts = n;
return this;
};


Job.prototype.failedAttempt = function( theErr, fn ) {
this.error(theErr).failed(function() {
  this.<span class="apidocCodeKeywordSpan">attempt</span>(function( error, remaining, attempts/*, max*/ ) {
    if( error ) {
      this.emit( &#x27;error&#x27;, error );
      return fn &#x26;&#x26; fn( error );
    }
    if( remaining &#x3e; 0 ) {
      this.reattempt(attempts, function( err ) {
        if( err ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.attempts" id="apidoc.element.kue.Job.prototype.attempts">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>attempts
        <span class="apidocSignatureSpan">( n )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attempts = function ( n ) {
  this._max_attempts = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* UI: scroll details into view

0.0.3 / 2011-07-07
==================

* Added caustic to aid in template management
* Added job attempt support. Closes #31
* Added `Job.<span class="apidocCodeKeywordSpan">attempts</span>(n)`
* Added minified jQuery
* Added cluster integration docs. Closes #13
* Added GET _/jobs/:from..:to_ to JSON API
* Fixed: hide &#x22;More&#x22; on sort
* Fixed: hide &#x22;More&#x22; on filter
* Fixed: removed &#x22;error&#x22; emission, blows up when no one is listening
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.backoff" id="apidoc.element.kue.Job.prototype.backoff">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>backoff
        <span class="apidocSignatureSpan">( param )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backoff = function ( param ) {
  if( 0 == arguments.length ) return this._backoff;
  this._backoff = param;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Failure Backoff
Job retry attempts are done as soon as they fail, with no delay, even if your job had a delay set via `Job#delay`. If you want to
 delay job re-attempts upon failures (known as backoff) you can use `Job#backoff` method in different ways:

```js
// Honor job&#x27;s original delay (if set) at each attempt, defaults to fixed backoff
job.attempts(3).<span class="apidocCodeKeywordSpan">backoff</span>( true )

// Override delay value, fixed backoff
job.attempts(3).backoff( {delay: 60*1000, type:&#x27;fixed&#x27;} )

// Enable exponential backoff using original delay (if set)
job.attempts(3).backoff( {type:&#x27;exponential&#x27;} )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.complete" id="apidoc.element.kue.Job.prototype.complete">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>complete
        <span class="apidocSignatureSpan">( clbk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function ( clbk ) {
  return this.set(&#x27;progress&#x27;, 100).state(&#x27;complete&#x27;, clbk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  try {
    job.result = result;
    job.set(&#x27;result&#x27;, JSON.stringify(result), noop);
  } catch(e) {
    job.set(&#x27;result&#x27;, JSON.stringify({ error: true, message: &#x27;Invalid JSON Result: &#x22;&#x27; + result + &#x27;&#
x22;&#x27; }), noop);
  }
}
job.<span class="apidocCodeKeywordSpan">complete</span>(function() {
  job.attempt(function() {
    if( job.removeOnComplete() ) {
      job.remove();
    }
    self.emitJobEvent(&#x27;complete&#x27;, job, result);
    self.start(fn);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.delay" id="apidoc.element.kue.Job.prototype.delay">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>delay
        <span class="apidocSignatureSpan">( ms )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function ( ms ) {
  if( 0 == arguments.length ) return this._delay;
  if( _.isDate(ms) ) {
    ms = parseInt(ms.getTime() - Date.now())
  }
  if( ms &#x3e; 0 ) {
    this._delay = ms;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

The events available are the same as mentioned in &#x22;Job Events&#x22;, however prefixed with &#x22;job &#x22;.

### Delayed Jobs

Delayed jobs may be scheduled to be queued for an arbitrary distance in time by invoking the `.<span class="apidocCodeKeywordSpan
">delay</span>(ms)` method, passing the number of milliseconds relative to _now_. Alternatively, you can pass a JavaScript `Date
` object with a specific time in the future.
This automatically flags the `Job` as &#x22;delayed&#x22;.

```js
var email = queue.create(&#x27;email&#x27;, {
  title: &#x27;Account renewal required&#x27;
, to: &#x27;tj@learnboost.com&#x27;
, template: &#x27;renewal-email&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.delayed" id="apidoc.element.kue.Job.prototype.delayed">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>delayed
        <span class="apidocSignatureSpan">( clbk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayed = function ( clbk ) {
  return this.state(&#x27;delayed&#x27;, clbk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      } catch(e) {
        clbk(e);
      }
    }
    var self = this;
    this.delay(delay).update(function( err ) {
      if( err ) return clbk(err);
      self.<span class="apidocCodeKeywordSpan">delayed</span>(clbk);
    });
  } else {
    this.inactive(clbk);
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.error" id="apidoc.element.kue.Job.prototype.error">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>error
        <span class="apidocSignatureSpan">( err )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function ( err ) {
  var str, summary;
  if( 0 == arguments.length ) return this._error;

  if( &#x27;string&#x27; == typeof err ) {
    str     = err;
    summary = &#x27;&#x27;;
  } else {
    if( err.stack &#x26;&#x26; &#x27;string&#x27; === typeof err.stack ) {
      str = err.stack
    } else { //TODO what happens to CallSite[] err.stack?
      str = err.message
    }
    summary = (&#x27;string&#x27; === typeof str) ? str.split(&#x27;\n&#x27;)[ 0 ] : &#x27;&#x27;;
  }
  this.set(&#x27;error&#x27;, str);
  this.log(&#x27;%s&#x27;, summary);
  events.emit(this.id, &#x27;error&#x27;, str);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



2. Binding to `uncaughtException` and gracefully shutting down the Kue, however this is not a recommended error handling idiom in
 javascript since you are losing the error context.

```js
process.once( &#x27;uncaughtException&#x27;, function(err){
  console.<span class="apidocCodeKeywordSpan">error</span>( &#x27;Something bad happened: &#x27;, err );
  queue.shutdown( 1000, function(err2){
    console.error( &#x27;Kue shutdown result: &#x27;, err2 || &#x27;OK&#x27; );
    process.exit( 0 );
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.events" id="apidoc.element.kue.Job.prototype.events">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>events
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">events = function (events) {
  this._jobEvents = !!events;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 ```js
 kue.createQueue({jobEvents: false})
 ```

 Alternatively, you can use the job level function `events` to control whether events are fired for a job at the job level.

 ```js
var job = queue.create(&#x27;test&#x27;).<span class="apidocCodeKeywordSpan">events</span>(false).save();
 ```

### Queue Events

Queue-level events provide access to the job-level events previously mentioned, however scoped to the `Queue` instance to apply
logic at a &#x22;global&#x22; level. An example of this is removing completed jobs:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.failed" id="apidoc.element.kue.Job.prototype.failed">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>failed
        <span class="apidocSignatureSpan">( clbk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failed = function ( clbk ) {
  this.failed_at = Date.now();
  return this.set(&#x27;failed_at&#x27;, this.failed_at).state(&#x27;failed&#x27;, clbk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Job.prototype.attempts = function( n ) {
this._max_attempts = n;
return this;
};


Job.prototype.failedAttempt = function( theErr, fn ) {
this.error(theErr).<span class="apidocCodeKeywordSpan">failed</span>(function() {
  this.attempt(function( error, remaining, attempts/*, max*/ ) {
    if( error ) {
      this.emit( &#x27;error&#x27;, error );
      return fn &#x26;&#x26; fn( error );
    }
    if( remaining &#x3e; 0 ) {
      this.reattempt(attempts, function( err ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.failedAttempt" id="apidoc.element.kue.Job.prototype.failedAttempt">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>failedAttempt
        <span class="apidocSignatureSpan">( theErr, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failedAttempt = function ( theErr, fn ) {
  this.error(theErr).failed(function() {
    this.attempt(function( error, remaining, attempts/*, max*/ ) {
      if( error ) {
        this.emit( &#x27;error&#x27;, error );
        return fn &#x26;&#x26; fn( error );
      }
      if( remaining &#x3e; 0 ) {
        this.reattempt(attempts, function( err ) {
          if( err ) {
            this.emit( &#x27;error&#x27;, err );
            return fn &#x26;&#x26; fn( err );
          }
          fn &#x26;&#x26; fn( err, true, attempts );
        }.bind(this));
      } else if( remaining === 0 )  {
        fn &#x26;&#x26; fn( null, false, attempts );
      } else {
        fn &#x26;&#x26; fn( new Error(&#x27;Attempts Exceeded&#x27;) );
      }
    }.bind(this));
  }.bind(this));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

var waitForAcks = setTimeout( function(){
  idsRemaining.forEach( function( id ){
    id = client.stripFIFO(id);
    Job.get(id, function( err, job ) {
      if( err ) return doUnlock();
      job.<span class="apidocCodeKeywordSpan">failedAttempt</span>( { error: true, message: &#x27;TTL exceeded&#x27; }, doUnlock
 );
    });
  });
}, 1000 );

ids.forEach(function( id ) {
  id = client.stripFIFO(id);
  events.emit(id, &#x27;ttl exceeded&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.get" id="apidoc.element.kue.Job.prototype.get">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>get
        <span class="apidocSignatureSpan">( key, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function ( key, fn ) {
  this.client.hget(this.client.getKey(&#x27;job:&#x27; + this.id), key, fn || noop);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Queue-level events provide access to the job-level events previously mentioned, however scoped to the `Queue` instance to apply
logic at a &#x22;global&#x22; level. An example of this is removing completed jobs:

```js
queue.on(&#x27;job enqueue&#x27;, function(id, type){
  console.log( &#x27;Job %s got queued of type %s&#x27;, id, type );

}).on(&#x27;job complete&#x27;, function(id, result){
  kue.Job.<span class="apidocCodeKeywordSpan">get</span>(id, function(err, job){
    if (err) return;
    job.remove(function(err){
      if (err) throw err;
      console.log(&#x27;removed completed job #%d&#x27;, job.id);
    });
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.inactive" id="apidoc.element.kue.Job.prototype.inactive">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>inactive
        <span class="apidocSignatureSpan">( clbk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inactive = function ( clbk ) {
  return this.state(&#x27;inactive&#x27;, clbk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
```

and iterating over job ids

```js
queue.<span class="apidocCodeKeywordSpan">inactive</span>( function( err, ids ) { // others are active, complete, failed, delayed
  // you may want to fetch each id to get the Job object out of it...
});
```

however the second one doesn&#x27;t scale to large deployments, there you can use more specific `Job` static methods:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.log" id="apidoc.element.kue.Job.prototype.log">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>log
        <span class="apidocSignatureSpan">( str )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function ( str ) {
  if(typeof str === &#x27;string&#x27;) {
    var formatted = util.format.apply(util, arguments);
  }else{
    var formatted = util.inspect(str);
  }
  this.client.rpush(this.client.getKey(&#x27;job:&#x27; + this.id + &#x27;:log&#x27;), formatted, noop);
  this.set(&#x27;updated_at&#x27;, Date.now());
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var job = queue.create(&#x27;email&#x27;, {
    title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).save( function(err){
   if( !err ) console.<span class="apidocCodeKeywordSpan">log</span>( job.id );
});
```

### Job Priority

To specify the priority of a job, simply invoke the `priority()` method with a number, or priority name, which is mapped to a number
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.priority" id="apidoc.element.kue.Job.prototype.priority">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>priority
        <span class="apidocSignatureSpan">( level )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priority = function ( level ) {
  if( 0 == arguments.length ) return this._priority;
  this._priority = null == priorities[ level ]
    ? level
    : priorities[ level ];
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
To specify the priority of a job, simply invoke the `priority()` method with a number, or priority name, which is mapped to a number
.

```js
queue.create(&#x27;email&#x27;, {
title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).<span class="apidocCodeKeywordSpan">priority</span>(&#x27;high&#x27;).save();
```

The default priority map is as follows:

```js
{
low: 10
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.progress" id="apidoc.element.kue.Job.prototype.progress">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>progress
        <span class="apidocSignatureSpan">( complete, total, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function ( complete, total, data ) {
  if( 0 == arguments.length ) return this._progress;
  var n = Math.min(100, complete * 100 / total | 0);
  this.set(&#x27;progress&#x27;, n);

  // If this stringify fails because of a circular structure, even the one in events.emit would.
  // So it does not make sense to try/catch this.
  if( data ) this.set(&#x27;progress_data&#x27;, JSON.stringify(data));

  this.set(&#x27;updated_at&#x27;, Date.now());
  this.refreshTtl();
  events.emit(this.id, &#x27;progress&#x27;, n, data);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
job.log({key: &#x27;some key&#x27;, value: 10});
job.log({[1,2,3,5,8]});
job.log(10.1);
```

### Job Progress

Job progress is extremely useful for long-running jobs such as video conversion. To update the job&#x27;s progress simply invoke
 `job.<span class="apidocCodeKeywordSpan">progress</span>(completed, total [, data])`:

```js
job.progress(frames, totalFrames);
```

data can be used to pass extra information about the job. For example a message or an object with some extra contextual data to
the current status.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.reattempt" id="apidoc.element.kue.Job.prototype.reattempt">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>reattempt
        <span class="apidocSignatureSpan">( attempts, clbk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reattempt = function ( attempts, clbk ) {
  clbk = clbk || noop;
  if( this.backoff() ) {
    var delay = this.delay();
    if( _.isFunction(this._getBackoffImpl()) ) {
      try {
        delay = this._getBackoffImpl().apply(this, [ attempts ]);
      } catch(e) {
        clbk(e);
      }
    }
    var self = this;
    this.delay(delay).update(function( err ) {
      if( err ) return clbk(err);
      self.delayed(clbk);
    });
  } else {
    this.inactive(clbk);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.error(theErr).failed(function() {
this.attempt(function( error, remaining, attempts/*, max*/ ) {
  if( error ) {
    this.emit( &#x27;error&#x27;, error );
    return fn &#x26;&#x26; fn( error );
  }
  if( remaining &#x3e; 0 ) {
    this.<span class="apidocCodeKeywordSpan">reattempt</span>(attempts, function( err ) {
      if( err ) {
        this.emit( &#x27;error&#x27;, err );
        return fn &#x26;&#x26; fn( err );
      }
      fn &#x26;&#x26; fn( err, true, attempts );
    }.bind(this));
  } else if( remaining === 0 )  {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.refreshTtl" id="apidoc.element.kue.Job.prototype.refreshTtl">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>refreshTtl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshTtl = function () {
  (&#x27;active&#x27; === this.state() &#x26;&#x26; this._ttl &#x3e; 0)
    ?
    this.client.zadd(this.client.getKey(&#x27;jobs:&#x27; + this.state()), Date.now() + parseInt(this._ttl), this.zid, noop)
    :
    noop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.set(&#x27;progress&#x27;, n);

 // If this stringify fails because of a circular structure, even the one in events.emit would.
 // So it does not make sense to try/catch this.
 if( data ) this.set(&#x27;progress_data&#x27;, JSON.stringify(data));

 this.set(&#x27;updated_at&#x27;, Date.now());
 this.<span class="apidocCodeKeywordSpan">refreshTtl</span>();
 events.emit(this.id, &#x27;progress&#x27;, n, data);
 return this;
};

/**
* Set the job delay in `ms`.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.remove" id="apidoc.element.kue.Job.prototype.remove">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>remove
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function ( fn ) {
  var client = this.client;
  client.multi()
    .zrem(client.getKey(&#x27;jobs:&#x27; + this.state()), this.zid)
    .zrem(client.getKey(&#x27;jobs:&#x27; + this.type + &#x27;:&#x27; + this.state()), this.zid)
    .zrem(client.getKey(&#x27;jobs&#x27;), this.zid)
    .del(client.getKey(&#x27;job:&#x27; + this.id + &#x27;:log&#x27;))
    .del(client.getKey(&#x27;job:&#x27; + this.id))
    .exec(function( err ) {
//            events.remove(this);
      events.emit(this.id, &#x27;remove&#x27;, this.type);
      if( !exports.disableSearch ) {
        getSearch().remove(this.id, fn);
      } else {
        fn &#x26;&#x26; fn(err);
      }
    }.bind(this));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
queue.on(&#x27;job enqueue&#x27;, function(id, type){
  console.log( &#x27;Job %s got queued of type %s&#x27;, id, type );

}).on(&#x27;job complete&#x27;, function(id, result){
  kue.Job.get(id, function(err, job){
    if (err) return;
    job.<span class="apidocCodeKeywordSpan">remove</span>(function(err){
      if (err) throw err;
      console.log(&#x27;removed completed job #%d&#x27;, job.id);
    });
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.removeOnComplete" id="apidoc.element.kue.Job.prototype.removeOnComplete">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>removeOnComplete
        <span class="apidocSignatureSpan">( param )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeOnComplete = function ( param ) {
  if( 0 == arguments.length ) return this._removeOnComplete;
  this._removeOnComplete = param;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Bulk job create JSON API, Closes #334, Closes #500, Closes #527
* Add feature to specify redis connection string/url, Closes #540
* Mention kue-ui in readme, Closes #502
* Add an extra parameter to the progress method to notify extra contextual data, Closes #466, Closes #427, Closes #313
* Document job event callback arguments, Closes #542
* Fix typo in documentation, Closes #506
* Document importance of using Kue `error` listeners, Closes #409
* Document Queue maintenance and job.<span class="apidocCodeKeywordSpan">removeOnComplete</span>( true ), Closes #439
* Document how to query all the active jobs programmatically, Closes #418
* Document to explain how &#x22;stuck queued jobs&#x22; happens, Closes #451
* Document on proper error handling to prevent stuck jobs, Closes #391


0.8.11 / 2014-12-15
===================
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.save" id="apidoc.element.kue.Job.prototype.save">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>save
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function ( fn ) {
  var client = this.client
    , fn     = fn || noop
    , max    = this._max_attempts
    , self   = this;

  // update
  if( this.id ) return this.update(fn);

  // incr id
  client.incr(client.getKey(&#x27;ids&#x27;), function( err, id ) {
    if( err ) return fn(err);
    // add the job for event mapping
    self.id = id;
    self.zid = client.createFIFO(id);
    self.subscribe(function() {
      self._state     = self._state || (this._delay ? &#x27;delayed&#x27; : &#x27;inactive&#x27;);
      if( max ) { self.set(&#x27;max_attempts&#x27;, max); }
      client.sadd(client.getKey(&#x27;job:types&#x27;), self.type, noop);
      self.set(&#x27;type&#x27;, self.type);
      var now         = Date.now();
      self.created_at = now;
      self.set(&#x27;created_at&#x27;, self.created_at);
      self.promote_at = now + (self._delay || 0);
      self.set(&#x27;promote_at&#x27;, self.promote_at);
      self.update(fn);
    }.bind(this));
  }.bind(this));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Calling `queue.create()` with the type of job (&#x22;email&#x22;), and arbitrary job data will return a `Job`, which can then be
 `save()`ed, adding it to redis, with a default priority level of &#x22;normal&#x22;. The `save()` method optionally accepts a callback
, responding with an `error` if something goes wrong. The `title` key is special-cased, and will display in the job listings within
 the UI, making it easier to find a specific job.

```js
var job = queue.create(&#x27;email&#x27;, {
    title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).<span class="apidocCodeKeywordSpan">save</span>( function(err){
   if( !err ) console.log( job.id );
});
```

### Job Priority

To specify the priority of a job, simply invoke the `priority()` method with a number, or priority name, which is mapped to a number
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.searchKeys" id="apidoc.element.kue.Job.prototype.searchKeys">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>searchKeys
        <span class="apidocSignatureSpan">( keys )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">searchKeys = function ( keys ) {
  if( 0 == arguments.length ) return this._searchKeys;
  this._searchKeys = keys || [];
  if( !_.isArray(this._searchKeys) ) {
    this._searchKeys = [ this._searchKeys ];
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var kue = require(&#x27;kue&#x27;);
queue = kue.createQueue();
queue.create(&#x27;email&#x27;, {
    title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).<span class="apidocCodeKeywordSpan">searchKeys</span>( [&#x27;to&#x27;, &#x27;title&#x27;] ).save();
```

Search feature is turned off by default from Kue `&#x3e;=0.9.0`. Read more about this [here](https://github.com/Automattic/kue/issues
/412). You should enable search indexes and add [reds](https://www.npmjs.com/package/reds) in your dependencies if you need to:

```javascript
var kue = require(&#x27;kue&#x27;);
q = kue.createQueue({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.set" id="apidoc.element.kue.Job.prototype.set">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>set
        <span class="apidocSignatureSpan">( key, val, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function ( key, val, fn ) {
  this.client.hset(this.client.getKey(&#x27;job:&#x27; + this.id), key, val, fn || noop);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
kue.createQueue(...);
kue.app.listen(3000);
```

The title defaults to &#x22;Kue&#x22;, to alter this invoke:

```js
kue.app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;title&#x27;, &#x27;My Application&#x27;);
```

**Note** *that if you are using non-default Kue options, `kue.createQueue(...)` must be called before accessing `kue.app`.*

### Third-party interfaces

You can also use [Kue-UI](https://github.com/StreetHub/kue-ui) web interface contributed by [Arnaud Bénard](https://github.com/arnaudbenard
)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.state" id="apidoc.element.kue.Job.prototype.state">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>state
        <span class="apidocSignatureSpan">( state, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">state = function ( state, fn ) {
  if( 0 == arguments.length ) return this._state;
  var client   = this.client
    , fn       = fn || noop;
  var oldState = this._state;
  var multi    = client.multi();
  if( oldState &#x26;&#x26; oldState != &#x27;&#x27; &#x26;&#x26; oldState != state ) {
    multi
      .zrem(client.getKey(&#x27;jobs:&#x27; + oldState), this.zid)
      .zrem(client.getKey(&#x27;jobs:&#x27; + this.type + &#x27;:&#x27; + oldState), this.zid);
  }
  multi
    .hset(client.getKey(&#x27;job:&#x27; + this.id), &#x27;state&#x27;, state)
    .zadd(client.getKey(&#x27;jobs:&#x27; + state), this._priority, this.zid)
    .zadd(client.getKey(&#x27;jobs:&#x27; + this.type + &#x27;:&#x27; + state), this._priority, this.zid);

  // use promote_at as score when job moves to delayed
  (&#x27;delayed&#x27; === state) ? multi.zadd(client.getKey(&#x27;jobs:&#x27; + state), parseInt(this.promote_at), this.zid) : noop();
  (&#x27;active&#x27; === state &#x26;&#x26; this._ttl &#x3e; 0) ? multi.zadd(client.getKey(&#x27;jobs:&#x27; + state), Date.now() + parseInt(this._ttl), this.zid) :
noop();
  (&#x27;active&#x27; === state &#x26;&#x26; !this._ttl) ? multi.zadd(client.getKey(&#x27;jobs:&#x27; + state), this._priority&#x3c;0?this._priority:-this._priority
, this.zid) : noop();
  (&#x27;inactive&#x27; === state) ? multi.lpush(client.getKey(this.type + &#x27;:jobs&#x27;), 1) : noop();

  this.set(&#x27;updated_at&#x27;, Date.now());
  this._state = state;
  multi.exec(function( err, replies ) {
    if( !err ) {
      (this._state === &#x27;inactive&#x27;) ? events.emit(this.id, &#x27;enqueue&#x27;, this.type) : noop();
    }
    return fn(err);
  }.bind(this));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Completed jobs.
* @param {Function} fn
* @return {Queue} for chaining
* @api public
*/

Queue.prototype.complete = function( fn ) {
 return this.<span class="apidocCodeKeywordSpan">state</span>(&#x27;complete&#x27;, fn);
};

/**
* Failed jobs.
* @param {Function} fn
* @return {Queue} for chaining
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.subscribe" id="apidoc.element.kue.Job.prototype.subscribe">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>subscribe
        <span class="apidocSignatureSpan">( callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function ( callback ) {
  if( this._jobEvents ) {
    events.add(this, callback);
  } else {
    callback &#x26;&#x26; callback();
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @api public
*/

exports.createQueue = function( options ) {
 if( !Queue.singleton ) {
   Queue.singleton = new Queue(options);
 }
 events.<span class="apidocCodeKeywordSpan">subscribe</span>();
 return Queue.singleton;

};

/**
* Store workers
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.toJSON" id="apidoc.element.kue.Job.prototype.toJSON">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    id: this.id
    , type: this.type
    , data: this.data
    , result: this.result
    , priority: this._priority
    , progress: this._progress || 0
    , progress_data: this.progress_data
    , state: this._state
    , error: this._error
    , created_at: this.created_at
    , promote_at: this.promote_at
    , updated_at: this.updated_at
    , failed_at: this.failed_at
    , started_at: this.started_at
    , duration: this.duration
    , delay: this._delay
    , workerId: this.workerId
    , ttl: this._ttl
    , attempts: {
      made: Number(this._attempts) || 0
      , remaining: this._attempts &#x3e; 0 ? this._max_attempts - this._attempts : Number(this._max_attempts) || 1
      , max: Number(this._max_attempts) || 1
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.ttl" id="apidoc.element.kue.Job.prototype.ttl">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>ttl
        <span class="apidocSignatureSpan">( param )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ttl = function ( param ) {
  if( 0 == arguments.length ) return this._ttl;
  if( param &#x3e; 0 ) {
    this._ttl = param;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
In the last scenario, provided function will be executed (via eval) on each re-attempt to get next attempt delay value, meaning
that you can&#x27;t reference external/context variables within it.

### Job TTL

Job producers can set an expiry value for the time their job can live in active state, so that if workers didn&#x27;t reply in timely
 fashion, Kue will fail it with `TTL exceeded` error message preventing that job from being stuck in active state and spoiling concurrency
.

```js
queue.create(&#x27;email&#x27;, {title: &#x27;email job with TTL&#x27;}).<span class="apidocCodeKeywordSpan">ttl</span>(milliseconds
).save();
```

### Job Logs

Job-specific logs enable you to expose information to the UI at any point in the job&#x27;s life-time. To do so simply invoke `job
.log()`, which accepts a message string as well as variable-arguments for sprintf-like support:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.Job.prototype.update" id="apidoc.element.kue.Job.prototype.update">
        function <span class="apidocSignatureSpan">kue.Job.prototype.</span>update
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function ( fn ) {
  var json;

  // serialize json data
  try {
    json = JSON.stringify(this.data);
  } catch(err) {
    fn(err);
    return this;
  }

  // delay
  if( this._delay ) {
    this.set(&#x27;delay&#x27;, this._delay);
    if( this.created_at ) {
      var timestamp   = parseInt(this.failed_at || this.created_at, 10)
        , delay       = parseInt(this._delay);
      this.promote_at = timestamp + delay;
      this.set(&#x27;promote_at&#x27;, this.promote_at);
    }
  }
  if( this._ttl ) {
    this.set(&#x27;ttl&#x27;, this._ttl);
  }
  if( this._removeOnComplete ) this.set(&#x27;removeOnComplete&#x27;, this._removeOnComplete);
  if( this._backoff ) {
    if( _.isPlainObject(this._backoff) ) this.set(&#x27;backoff&#x27;, JSON.stringify(this._backoff));
    else this.set(&#x27;backoff&#x27;, this._backoff.toString());
  }

  // updated timestamp
  this.set(&#x27;updated_at&#x27;, Date.now());
  this.refreshTtl();

  // priority
  this.set(&#x27;priority&#x27;, this._priority);

  this.client.zadd(this.client.getKey(&#x27;jobs&#x27;), this._priority, this.zid, noop);

  // data
  this.set(&#x27;data&#x27;, json, function() {
    // state
    this.state(this._state, fn);
  }.bind(this));

  if( !exports.disableSearch ) {
    if( this.searchKeys() ) {
      this.searchKeys().forEach(function( key ) {
        var value = _.get(this.data, key);
        if( !_.isString(value) ) {
          value = JSON.stringify(value);
        }
        getSearch().index(value, this.id);
      }.bind(this));
    } else {
      getSearch().index(json, this.id);
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      try {
        delay = this._getBackoffImpl().apply(this, [ attempts ]);
      } catch(e) {
        clbk(e);
      }
    }
    var self = this;
    this.delay(delay).<span class="apidocCodeKeywordSpan">update</span>(function( err ) {
      if( err ) return clbk(err);
      self.delayed(clbk);
    });
  } else {
    this.inactive(clbk);
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.events" id="apidoc.module.kue.events">module kue.events</a></h1>




    <h2>
        <a href="#apidoc.element.kue.events.add" id="apidoc.element.kue.events.add">
        function <span class="apidocSignatureSpan">kue.events.</span>add
        <span class="apidocSignatureSpan">( job, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function ( job, callback ) {
  if( job.id ) {
    if(!exports.jobs[ job.id ])
      exports.jobs[ job.id ] = [];

    exports.jobs[ job.id ].push(job);
  }
//  if (!exports.subscribed) exports.subscribe();
  if( !exports.subscribeStarted ) exports.subscribe();
  if( !exports.subscribed ) {
    exports.callbackQueue.push(callback);
  } else {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @return {Job} for chaining
 * @api public
 */

Job.prototype.subscribe = function( callback ) {
  if( this._jobEvents ) {
    events.<span class="apidocCodeKeywordSpan">add</span>(this, callback);
  } else {
    callback &#x26;&#x26; callback();
  }
  return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.events.emit" id="apidoc.element.kue.events.emit">
        function <span class="apidocSignatureSpan">kue.events.</span>emit
        <span class="apidocSignatureSpan">( id, event )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( id, event ) {
  var client = redis.client()
    , msg    = JSON.stringify({
        id: id, event: event, args: [].slice.call(arguments, 1)
      });
  client.publish(client.getKey(exports.key), msg, function () {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //, lockTtl = timeout
  , limit        = promotionOptions.limit || 1000;
clearInterval(this.promoter);
this.promoter    = setInterval(function() {
  self.warlock.lock(&#x27;promotion&#x27;, lockTtl, function( err, unlock ) {
    if( err ) {
      // Something went wrong and we weren&#x27;t able to set a lock
      self.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;error&#x27;, err);
      return;
    }
    if( typeof unlock === &#x27;function&#x27; ) {
      // If the lock is set successfully by this process, an unlock function is passed to our callback.
      client.zrangebyscore(client.getKey(&#x27;jobs:delayed&#x27;), 0, Date.now(), &#x27;LIMIT&#x27;, 0, limit, function( err, ids
 ) {
        if( err || !ids.length ) return unlock();
        //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.events.onMessage" id="apidoc.element.kue.events.onMessage">
        function <span class="apidocSignatureSpan">kue.events.</span>onMessage
        <span class="apidocSignatureSpan">( channel, msg )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onMessage = function ( channel, msg ) {
  // TODO: only subscribe on {Queue,Job}#on()
  msg = JSON.parse(msg);

  // map to Job when in-process
  var jobs = exports.jobs[ msg.id ];
  if( jobs &#x26;&#x26; jobs.length &#x3e; 0 ) {
    for (var i = 0; i &#x3c; jobs.length; i++) {
      var job = jobs[i];
      job.emit.apply(job, msg.args);
      if( [ &#x27;complete&#x27;, &#x27;failed&#x27; ].indexOf(msg.event) !== -1 ) exports.remove(job);
    }
  }
  // emit args on Queues
  msg.args[ 0 ] = &#x27;job &#x27; + msg.args[ 0 ];
  msg.args.splice(1, 0, msg.id);
  if( exports.queue ) {
    exports.queue.emit.apply(exports.queue, msg.args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.events.remove" id="apidoc.element.kue.events.remove">
        function <span class="apidocSignatureSpan">kue.events.</span>remove
        <span class="apidocSignatureSpan">( job )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function ( job ) {
  delete exports.jobs[ job.id ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
queue.on(&#x27;job enqueue&#x27;, function(id, type){
  console.log( &#x27;Job %s got queued of type %s&#x27;, id, type );

}).on(&#x27;job complete&#x27;, function(id, result){
  kue.Job.get(id, function(err, job){
    if (err) return;
    job.<span class="apidocCodeKeywordSpan">remove</span>(function(err){
      if (err) throw err;
      console.log(&#x27;removed completed job #%d&#x27;, job.id);
    });
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.events.subscribe" id="apidoc.element.kue.events.subscribe">
        function <span class="apidocSignatureSpan">kue.events.</span>subscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function () {
//  if (exports.subscribed) return;
  if( exports.subscribeStarted ) return;
  var client    = redis.pubsubClient();
  client.on(&#x27;message&#x27;, exports.onMessage);
  client.subscribe(client.getKey(exports.key),  function() {
    exports.subscribed = true;
    while( exports.callbackQueue.length ) {
      process.nextTick(exports.callbackQueue.shift());
    }
  });
  exports.queue = require(&#x27;../kue&#x27;).singleton;
//  exports.subscribed = true;
  exports.subscribeStarted = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @api public
*/

exports.createQueue = function( options ) {
 if( !Queue.singleton ) {
   Queue.singleton = new Queue(options);
 }
 events.<span class="apidocCodeKeywordSpan">subscribe</span>();
 return Queue.singleton;

};

/**
* Store workers
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.events.unsubscribe" id="apidoc.element.kue.events.unsubscribe">
        function <span class="apidocSignatureSpan">kue.events.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function () {
  var client               = redis.pubsubClient();
  client.unsubscribe();
  client.removeAllListeners();
  exports.subscribeStarted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var cleanup = function() {
if( self.shuttingDown ) {
  self.workers    = [];
  exports.workers = [];
  self.removeAllListeners();
  Queue.singleton = null;
  events.<span class="apidocCodeKeywordSpan">unsubscribe</span>();
  // destroy redis client and pubsub
  redis.reset();
  self.client &#x26;&#x26; self.client.quit();
  self.client = null;
  self.lockClient &#x26;&#x26; self.lockClient.quit();
  self.lockClient = null;
}
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.json" id="apidoc.module.kue.json">module kue.json</a></h1>


    <h2>
        <a href="#apidoc.element.kue.json.createJob" id="apidoc.element.kue.json.createJob">
        function <span class="apidocSignatureSpan">kue.json.</span>createJob
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createJob = function ( req, res ) {
  var body = req.body;

  function _create( args, next ) {
    if( !args.type ) return next({ error: &#x27;Must provide job type&#x27; }, null, 400);

    var job     = new Job(args.type, args.data || {});
    var options = args.options || {};
    if( options.attempts ) job.attempts(parseInt(options.attempts));
    if( options.priority ) job.priority(options.priority);
    if( options.delay ) job.delay(options.delay);
    if( options.searchKeys ) job.searchKeys(options.searchKeys);
    if( options.backoff ) job.backoff(options.backoff);
    if( options.removeOnComplete ) job.removeOnComplete(options.removeOnComplete);
    if( options.ttl ) job.ttl(options.ttl);

    job.save(function( err ) {
      if( err ) {
        return next({ error: err.message }, null, 500);
      }
      else {
        return next(null, { message: &#x27;job created&#x27;, id: job.id });
      }
    });
  }

  if( !lodash.isEmpty(body) ) {
    if( lodash.isArray(body) ) {
      var returnErrorCode = 0; // Default: we don&#x27;t have any error
      var i      = 0, len = body.length;
      var result = [];
      -function _iterate() {
        _create(body[ i ], function( err, status, errCode ) {
          result.push(err || status);
          if( err ) {
            // Set an error code for the response
            if( !returnErrorCode ) {
              returnErrorCode = errCode || 500;
            }
          }

          // Keep processing even after an error
          i++;
          if( i &#x3c; len ) {
            _iterate();
          }
          else {
            // If we had an error code, return it
            if( returnErrorCode ) {
              res.status(returnErrorCode);
            }

            res.json(result);
          }
        })
      }()
    }
    else {
      _create(body, function( err, status, errCode ) {
        if( err ) {
          res.status(errCode || 500).json(err);
        }
        else {
          res.json(status);
        }
      })
    }
  }
  else {
    res.status(204); // &#x22;No content&#x22; status code
    res.end();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

after(function() {
  queue.testMode.exit()
});

it(&#x27;does something cool&#x27;, function() {
  queue.<span class="apidocCodeKeywordSpan">createJob</span>(&#x27;myJob&#x27;, { foo: &#x27;bar&#x27; }).save();
  queue.createJob(&#x27;anotherJob&#x27;, { baz: &#x27;bip&#x27; }).save();
  expect(queue.testMode.jobs.length).to.equal(2);
  expect(queue.testMode.jobs[0].type).to.equal(&#x27;myJob&#x27;);
  expect(queue.testMode.jobs[0].data).to.eql({ foo: &#x27;bar&#x27; });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.inactive" id="apidoc.element.kue.json.inactive">
        function <span class="apidocSignatureSpan">kue.json.</span>inactive
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inactive = function ( req, res ) {
  var id = req.params.id;
  Job.get(id, function( err, job ) {
    if( err ) return res.json({ error: err.message });
    job.inactive();
    res.json({ message: &#x27;job &#x27; + id + &#x27; inactive&#x27; });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
```

and iterating over job ids

```js
queue.<span class="apidocCodeKeywordSpan">inactive</span>( function( err, ids ) { // others are active, complete, failed, delayed
  // you may want to fetch each id to get the Job object out of it...
});
```

however the second one doesn&#x27;t scale to large deployments, there you can use more specific `Job` static methods:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.job" id="apidoc.element.kue.json.job">
        function <span class="apidocSignatureSpan">kue.json.</span>job
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">job = function ( req, res ) {
  var id = req.params.id;
  Job.get(id, function( err, job ) {
    if( err ) return res.json({ error: err.message });
    res.json(job);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.jobRange" id="apidoc.element.kue.json.jobRange">
        function <span class="apidocSignatureSpan">kue.json.</span>jobRange
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jobRange = function ( req, res ) {
  var from  = parseInt(req.params.from, 10)
    , to    = parseInt(req.params.to, 10)
    , order = req.params.order;

  Job.range(from, to, order, function( err, jobs ) {
    if( err ) return res.json({ error: err.message });
    res.json(jobs);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.jobStateRange" id="apidoc.element.kue.json.jobStateRange">
        function <span class="apidocSignatureSpan">kue.json.</span>jobStateRange
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jobStateRange = function ( req, res ) {
  var state = req.params.state
    , from  = parseInt(req.params.from, 10)
    , to    = parseInt(req.params.to, 10)
    , order = req.params.order;

  Job.rangeByState(state, from, to, order, function( err, jobs ) {
    if( err ) return res.json({ error: err.message });
    res.json(jobs);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.jobTypeRange" id="apidoc.element.kue.json.jobTypeRange">
        function <span class="apidocSignatureSpan">kue.json.</span>jobTypeRange
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jobTypeRange = function ( req, res ) {
  var type  = req.params.type
    , state = req.params.state
    , from  = parseInt(req.params.from, 10)
    , to    = parseInt(req.params.to, 10)
    , order = req.params.order;

  Job.rangeByType(type, state, from, to, order, function( err, jobs ) {
    if( err ) return res.json({ error: err.message });
    res.json(jobs);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.jobTypeStateStats" id="apidoc.element.kue.json.jobTypeStateStats">
        function <span class="apidocSignatureSpan">kue.json.</span>jobTypeStateStats
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jobTypeStateStats = function ( req, res ) {
  var type  = req.params.type
    , state = req.params.state;

  queue.cardByType(type, state, function( err, count ) {
    if( err ) return res.json({ error: err.message });
    res.json({ count: count });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.log" id="apidoc.element.kue.json.log">
        function <span class="apidocSignatureSpan">kue.json.</span>log
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function ( req, res ) {
  var id = req.params.id;
  Job.log(id, function( err, log ) {
    if( err ) return res.json({ error: err.message });
    res.json(log);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var job = queue.create(&#x27;email&#x27;, {
    title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).save( function(err){
   if( !err ) console.<span class="apidocCodeKeywordSpan">log</span>( job.id );
});
```

### Job Priority

To specify the priority of a job, simply invoke the `priority()` method with a number, or priority name, which is mapped to a number
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.remove" id="apidoc.element.kue.json.remove">
        function <span class="apidocSignatureSpan">kue.json.</span>remove
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function ( req, res ) {
  var id = req.params.id;
  Job.remove(id, function( err ) {
    if( err ) return res.json({ error: err.message });
    res.json({ message: &#x27;job &#x27; + id + &#x27; removed&#x27; });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
queue.on(&#x27;job enqueue&#x27;, function(id, type){
  console.log( &#x27;Job %s got queued of type %s&#x27;, id, type );

}).on(&#x27;job complete&#x27;, function(id, result){
  kue.Job.get(id, function(err, job){
    if (err) return;
    job.<span class="apidocCodeKeywordSpan">remove</span>(function(err){
      if (err) throw err;
      console.log(&#x27;removed completed job #%d&#x27;, job.id);
    });
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.search" id="apidoc.element.kue.json.search">
        function <span class="apidocSignatureSpan">kue.json.</span>search
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function ( req, res ) {
  getSearch().query(req.query.q).end(function( err, ids ) {
    if( err ) return res.json({ error: err.message });
    res.json(ids);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.stats" id="apidoc.element.kue.json.stats">
        function <span class="apidocSignatureSpan">kue.json.</span>stats
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stats = function ( req, res ) {
  get(queue)
  (&#x27;inactiveCount&#x27;)
  (&#x27;completeCount&#x27;)
  (&#x27;activeCount&#x27;)
  (&#x27;failedCount&#x27;)
  (&#x27;delayedCount&#x27;)
  (&#x27;workTime&#x27;)
  (function( err, obj ) {
    if( err ) return res.json({ error: err.message });
    res.json(obj);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.types" id="apidoc.element.kue.json.types">
        function <span class="apidocSignatureSpan">kue.json.</span>types
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">types = function ( req, res ) {
  queue.types(function( err, types ) {
    if( err ) return res.json({ error: err.message });
    res.json(types);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Serve the index page.
 */

exports.jobs = function( state ) {
  return function( req, res ) {
    queue.<span class="apidocCodeKeywordSpan">types</span>(function( err, types ) {
      res.render(&#x27;job/list&#x27;, {
        state: state, types: types, title: req.app.get(&#x27;title&#x27;)
      });
    });
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.updatePriority" id="apidoc.element.kue.json.updatePriority">
        function <span class="apidocSignatureSpan">kue.json.</span>updatePriority
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updatePriority = function ( req, res ) {
  var id       = req.params.id
    , priority = parseInt(req.params.priority, 10);

  if( isNaN(priority) ) return res.json({ error: &#x27;invalid priority&#x27; });
  Job.get(id, function( err, job ) {
    if( err ) return res.json({ error: err.message });
    job.priority(priority);
    job.save(function( err ) {
      if( err ) return res.json({ error: err.message });
      res.json({ message: &#x27;updated priority&#x27; });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.json.updateState" id="apidoc.element.kue.json.updateState">
        function <span class="apidocSignatureSpan">kue.json.</span>updateState
        <span class="apidocSignatureSpan">( req, res )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateState = function ( req, res ) {
  var id    = req.params.id
    , state = req.params.state;

  Job.get(id, function( err, job ) {
    if( err ) return res.json({ error: err.message });
    job.state(state);
    job.save(function( err ) {
      if( err ) return res.json({ error: err.message });
      res.json({ message: &#x27;updated state&#x27; });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.kue" id="apidoc.module.kue.kue">module kue.kue</a></h1>


    <h2>
        <a href="#apidoc.element.kue.kue.kue" id="apidoc.element.kue.kue.kue">
        function <span class="apidocSignatureSpan">kue.</span>kue
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue( options ) {
  options     = options || {};
  this.name   = options.name || &#x27;kue&#x27;;
  this.id = [ &#x27;kue&#x27;, require(&#x27;os&#x27;).hostname(), process.pid ].join(&#x27;:&#x27;);
  this._options   = options;
  this.promoter     = null;
  this.workers      = exports.workers;
  this.shuttingDown = false;
  Job.disableSearch = options.disableSearch !== false;
  options.jobEvents !== undefined ? Job.jobEvents = options.jobEvents : &#x27;&#x27;;
  redis.configureFactory(options, this);
  this.client = Worker.client = Job.client = redis.createClient();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.Job" id="apidoc.element.kue.kue.Job">
        function <span class="apidocSignatureSpan">kue.kue.</span>Job
        <span class="apidocSignatureSpan">( type, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Job( type, data ) {
  this.type          = type;
  this.data          = data || {};
  this._max_attempts = 1;
  this._jobEvents = exports.jobEvents;
//  this.client = redis.client();
  this.client = Job.client/* || (Job.client = redis.client())*/;
  this.priority(&#x27;normal&#x27;);
  this.on(&#x27;error&#x27;, function( err ) {
  });// prevent uncaught exceptions on failed job errors
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.createQueue" id="apidoc.element.kue.kue.createQueue">
        function <span class="apidocSignatureSpan">kue.kue.</span>createQueue
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createQueue = function ( options ) {
  if( !Queue.singleton ) {
    Queue.singleton = new Queue(options);
  }
  events.subscribe();
  return Queue.singleton;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  - [Screencasts](#screencasts)
  - [License](#license)



## Creating Jobs

First create a job `Queue` with `kue.<span class="apidocCodeKeywordSpan">createQueue</span>()`:

```js
var kue = require(&#x27;kue&#x27;)
  , queue = kue.createQueue();
```

Calling `queue.create()` with the type of job (&#x22;email&#x22;), and arbitrary job data will return a `Job`, which can then be
 `save()`ed, adding it to redis, with a default priority level of &#x22;normal&#x22;. The `save()` method optionally accepts a callback
, responding with an `error` if something goes wrong. The `title` key is special-cased, and will display in the job listings within
 the UI, making it easier to find a specific job.
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.kue.prototype" id="apidoc.module.kue.kue.prototype">module kue.kue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kue.kue.prototype.active" id="apidoc.element.kue.kue.prototype.active">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>active
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">active = function ( fn ) {
  return this.state(&#x27;active&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


### Programmatic Job Management

If you did none of above in [Error Handling](#error-handling) section or your process lost active jobs in any way, you can recover
 from them when your process is restarted. A blind logic would be to re-queue all stuck jobs:

```js
queue.<span class="apidocCodeKeywordSpan">active</span>( function( err, ids ) {
  ids.forEach( function( id ) {
    kue.Job.get( id, function( err, job ) {
      // Your application should check if job is a stuck one
      job.inactive();
    });
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.activeCount" id="apidoc.element.kue.kue.prototype.activeCount">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>activeCount
        <span class="apidocSignatureSpan">( type, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">activeCount = function ( type, fn ) {
  if( 1 == arguments.length ) {
    fn = type;
    return this.card(&#x27;active&#x27;, fn);
  }
  return this.cardByType(type, &#x27;active&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.card" id="apidoc.element.kue.kue.prototype.card">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>card
        <span class="apidocSignatureSpan">( state, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">card = function ( state, fn ) {
  fn = fn || noop;
  this.client.zcard(this.client.getKey(&#x27;jobs:&#x27; + state), fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return {Queue} for chaining
* @api public
*/

Queue.prototype.completeCount = function( type, fn ) {
 if( 1 == arguments.length ) {
   fn = type;
   return this.<span class="apidocCodeKeywordSpan">card</span>(&#x27;complete&#x27;, fn);
 }
 return this.cardByType(type, &#x27;complete&#x27;, fn);
};


/**
* Failed jobs of type `type` count.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.cardByType" id="apidoc.element.kue.kue.prototype.cardByType">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>cardByType
        <span class="apidocSignatureSpan">( type, state, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cardByType = function ( type, state, fn ) {
  fn = fn || noop;
  this.client.zcard(this.client.getKey(&#x27;jobs:&#x27; + type + &#x27;:&#x27; + state), fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

Queue.prototype.completeCount = function( type, fn ) {
 if( 1 == arguments.length ) {
   fn = type;
   return this.card(&#x27;complete&#x27;, fn);
 }
 return this.<span class="apidocCodeKeywordSpan">cardByType</span>(type, &#x27;complete&#x27;, fn);
};


/**
* Failed jobs of type `type` count.
* @param {String} type is optional
* @param {Function} fn
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.checkActiveJobTtl" id="apidoc.element.kue.kue.prototype.checkActiveJobTtl">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>checkActiveJobTtl
        <span class="apidocSignatureSpan">( ttlOptions )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkActiveJobTtl = function ( ttlOptions ) {
  ttlOptions              = ttlOptions || {};
  var client              = this.client
    , self                = this
    , timeout             = ttlOptions.interval || 1000
    , lockTtl             = 2000
    , limit               = ttlOptions.limit || 1000;
  clearInterval(this.activeJobsTtlTimer);
  this.activeJobsTtlTimer = setInterval(function() {
    self.warlock.lock(&#x27;activeJobsTTL&#x27;, lockTtl, function( err, unlock ) {
      if( err ) {
        // Something went wrong and we weren&#x27;t able to set a lock
        self.emit(&#x27;error&#x27;, err);
        return;
      }
      if( typeof unlock === &#x27;function&#x27; ) {
        // If the lock is set successfully by this process, an unlock function is passed to our callback.
        // filter only jobs set with a ttl (timestamped) between a large number and current time
        client.zrangebyscore(client.getKey(&#x27;jobs:active&#x27;), 100000, Date.now(), &#x27;LIMIT&#x27;, 0, limit, function( err, ids ) {
          if( err || !ids.length ) return unlock();

          var idsRemaining = ids.slice();
          var doUnlock = _.after(ids.length, function(){
            self.removeAllListeners( &#x27;job ttl exceeded ack&#x27; );
            waitForAcks &#x26;&#x26; clearTimeout( waitForAcks );
            unlock &#x26;&#x26; unlock();
          });

          self.on( &#x27;job ttl exceeded ack&#x27;, function( id ) {
            idsRemaining.splice( idsRemaining.indexOf( id ), 1 );
            doUnlock();
          });

          var waitForAcks = setTimeout( function(){
            idsRemaining.forEach( function( id ){
              id = client.stripFIFO(id);
              Job.get(id, function( err, job ) {
                if( err ) return doUnlock();
                job.failedAttempt( { error: true, message: &#x27;TTL exceeded&#x27; }, doUnlock );
              });
            });
          }, 1000 );

          ids.forEach(function( id ) {
            id = client.stripFIFO(id);
            events.emit(id, &#x27;ttl exceeded&#x27;);
          });
        });
      } else {
        // The lock was not established by us, be silent
      }
    });
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Queue.prototype.setupTimers = function() {
 if( this.warlock === undefined ) {
   this.lockClient = redis.createClient();
   this.warlock    = new Warlock(this.lockClient);
 }
 this.checkJobPromotion(this._options.promotion);
 this.<span class="apidocCodeKeywordSpan">checkActiveJobTtl</span>(this._options.promotion);
};

/**
* This new method is called by Kue when created
*
* Promote delayed jobs, checking every `ms`,
* defaulting to 1 second.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.checkJobPromotion" id="apidoc.element.kue.kue.prototype.checkJobPromotion">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>checkJobPromotion
        <span class="apidocSignatureSpan">( promotionOptions )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkJobPromotion = function ( promotionOptions ) {
  promotionOptions = promotionOptions || {};
  var client       = this.client
    , self         = this
    , timeout      = promotionOptions.interval || 1000
    , lockTtl      = 2000
      //, lockTtl = timeout
    , limit        = promotionOptions.limit || 1000;
  clearInterval(this.promoter);
  this.promoter    = setInterval(function() {
    self.warlock.lock(&#x27;promotion&#x27;, lockTtl, function( err, unlock ) {
      if( err ) {
        // Something went wrong and we weren&#x27;t able to set a lock
        self.emit(&#x27;error&#x27;, err);
        return;
      }
      if( typeof unlock === &#x27;function&#x27; ) {
        // If the lock is set successfully by this process, an unlock function is passed to our callback.
        client.zrangebyscore(client.getKey(&#x27;jobs:delayed&#x27;), 0, Date.now(), &#x27;LIMIT&#x27;, 0, limit, function( err, ids ) {
          if( err || !ids.length ) return unlock();
          //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1
          var doUnlock = _.after(ids.length, unlock);
          ids.forEach(function( id ) {
            id = client.stripFIFO(id);
            Job.get(id, function( err, job ) {
              if( err ) return doUnlock();
              events.emit(id, &#x27;promotion&#x27;);
              job.inactive(doUnlock);
            });
          });
        });
      } else {
        // The lock was not established by us, be silent
      }
    });
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

Queue.prototype.setupTimers = function() {
 if( this.warlock === undefined ) {
   this.lockClient = redis.createClient();
   this.warlock    = new Warlock(this.lockClient);
 }
 this.<span class="apidocCodeKeywordSpan">checkJobPromotion</span>(this._options.promotion);
 this.checkActiveJobTtl(this._options.promotion);
};

/**
* This new method is called by Kue when created
*
* Promote delayed jobs, checking every `ms`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.complete" id="apidoc.element.kue.kue.prototype.complete">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>complete
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function ( fn ) {
  return this.state(&#x27;complete&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  try {
    job.result = result;
    job.set(&#x27;result&#x27;, JSON.stringify(result), noop);
  } catch(e) {
    job.set(&#x27;result&#x27;, JSON.stringify({ error: true, message: &#x27;Invalid JSON Result: &#x22;&#x27; + result + &#x27;&#
x22;&#x27; }), noop);
  }
}
job.<span class="apidocCodeKeywordSpan">complete</span>(function() {
  job.attempt(function() {
    if( job.removeOnComplete() ) {
      job.remove();
    }
    self.emitJobEvent(&#x27;complete&#x27;, job, result);
    self.start(fn);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.completeCount" id="apidoc.element.kue.kue.prototype.completeCount">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>completeCount
        <span class="apidocSignatureSpan">( type, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completeCount = function ( type, fn ) {
  if( 1 == arguments.length ) {
    fn = type;
    return this.card(&#x27;complete&#x27;, fn);
  }
  return this.cardByType(type, &#x27;complete&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.create" id="apidoc.element.kue.kue.prototype.create">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>create
        <span class="apidocSignatureSpan">( type, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function ( type, data ) {
  return new Job(type, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
First create a job `Queue` with `kue.createQueue()`:

```js
var kue = require(&#x27;kue&#x27;)
  , queue = kue.createQueue();
```

Calling `queue.<span class="apidocCodeKeywordSpan">create</span>()` with the type of job (&#x22;email&#x22;), and arbitrary job
data will return a `Job`, which can then be `save()`ed, adding it to redis, with a default priority level of &#x22;normal&#x22;.
The `save()` method optionally accepts a callback, responding with an `error` if something goes wrong. The `title` key is special
-cased, and will display in the job listings within the UI, making it easier to find a specific job.

```js
var job = queue.create(&#x27;email&#x27;, {
    title: &#x27;welcome email for tj&#x27;
  , to: &#x27;tj@learnboost.com&#x27;
  , template: &#x27;welcome-email&#x27;
}).save( function(err){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.createJob" id="apidoc.element.kue.kue.prototype.createJob">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>createJob
        <span class="apidocSignatureSpan">( type, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createJob = function ( type, data ) {
  return new Job(type, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

after(function() {
  queue.testMode.exit()
});

it(&#x27;does something cool&#x27;, function() {
  queue.<span class="apidocCodeKeywordSpan">createJob</span>(&#x27;myJob&#x27;, { foo: &#x27;bar&#x27; }).save();
  queue.createJob(&#x27;anotherJob&#x27;, { baz: &#x27;bip&#x27; }).save();
  expect(queue.testMode.jobs.length).to.equal(2);
  expect(queue.testMode.jobs[0].type).to.equal(&#x27;myJob&#x27;);
  expect(queue.testMode.jobs[0].data).to.eql({ foo: &#x27;bar&#x27; });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.delayed" id="apidoc.element.kue.kue.prototype.delayed">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>delayed
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayed = function ( fn ) {
  return this.state(&#x27;delayed&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      } catch(e) {
        clbk(e);
      }
    }
    var self = this;
    this.delay(delay).update(function( err ) {
      if( err ) return clbk(err);
      self.<span class="apidocCodeKeywordSpan">delayed</span>(clbk);
    });
  } else {
    this.inactive(clbk);
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.delayedCount" id="apidoc.element.kue.kue.prototype.delayedCount">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>delayedCount
        <span class="apidocSignatureSpan">( type, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayedCount = function ( type, fn ) {
  if( 1 == arguments.length ) {
    fn = type;
    return this.card(&#x27;delayed&#x27;, fn);
  }
  return this.cardByType(type, &#x27;delayed&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.failed" id="apidoc.element.kue.kue.prototype.failed">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>failed
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failed = function ( fn ) {
  return this.state(&#x27;failed&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Job.prototype.attempts = function( n ) {
this._max_attempts = n;
return this;
};


Job.prototype.failedAttempt = function( theErr, fn ) {
this.error(theErr).<span class="apidocCodeKeywordSpan">failed</span>(function() {
  this.attempt(function( error, remaining, attempts/*, max*/ ) {
    if( error ) {
      this.emit( &#x27;error&#x27;, error );
      return fn &#x26;&#x26; fn( error );
    }
    if( remaining &#x3e; 0 ) {
      this.reattempt(attempts, function( err ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.failedCount" id="apidoc.element.kue.kue.prototype.failedCount">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>failedCount
        <span class="apidocSignatureSpan">( type, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failedCount = function ( type, fn ) {
  if( 1 == arguments.length ) {
    fn = type;
    return this.card(&#x27;failed&#x27;, fn);
  }
  return this.cardByType(type, &#x27;failed&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
```

you can also query on an specific job type:

```js
queue.<span class="apidocCodeKeywordSpan">failedCount</span>( &#x27;my-critical-job&#x27;, function( err, total ) {
  if( total &#x3e; 10000 ) {
    console.log( &#x27;This is tOoOo bad&#x27; );
  }
});
```

and iterating over job ids
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.inactive" id="apidoc.element.kue.kue.prototype.inactive">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>inactive
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inactive = function ( fn ) {
  return this.state(&#x27;inactive&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
```

and iterating over job ids

```js
queue.<span class="apidocCodeKeywordSpan">inactive</span>( function( err, ids ) { // others are active, complete, failed, delayed
  // you may want to fetch each id to get the Job object out of it...
});
```

however the second one doesn&#x27;t scale to large deployments, there you can use more specific `Job` static methods:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.inactiveCount" id="apidoc.element.kue.kue.prototype.inactiveCount">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>inactiveCount
        <span class="apidocSignatureSpan">( type, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inactiveCount = function ( type, fn ) {
  if( 1 == arguments.length ) {
    fn = type;
    return this.card(&#x27;inactive&#x27;, fn);
  }
  return this.cardByType(type, &#x27;inactive&#x27;, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Kue will be refactored to fully atomic job state management from version 1.0 and this will happen by lua scripts and/or BRPOPLPUSH
 combination. You can read more [here](https://github.com/Automattic/kue/issues/130) and [here](https://github.com/Automattic/kue
/issues/38).

## Queue Maintenance

Queue object has two type of methods to tell you about the number of jobs in each state

```js
queue.<span class="apidocCodeKeywordSpan">inactiveCount</span>( function( err, total ) { // others are activeCount, completeCount
, failedCount, delayedCount
  if( total &#x3e; 100000 ) {
    console.log( &#x27;We need some back pressure here&#x27; );
  }
});
```

you can also query on an specific job type:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.on" id="apidoc.element.kue.kue.prototype.on">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>on
        <span class="apidocSignatureSpan">( event )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( event ) {
  if( 0 == event.indexOf(&#x27;job&#x27;) ) events.subscribe();
  return on.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var job = queue.create(&#x27;video conversion&#x27;, {
  title: &#x27;converting loki\&#x27;s to avi&#x27;
, user: 1
, frames: 200
});

job.<span class="apidocCodeKeywordSpan">on</span>(&#x27;complete&#x27;, function(result){
console.log(&#x27;Job completed with data &#x27;, result);

}).on(&#x27;failed attempt&#x27;, function(errorMessage, doneAttempts){
console.log(&#x27;Job failed&#x27;);

}).on(&#x27;failed&#x27;, function(errorMessage){
console.log(&#x27;Job failed&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.process" id="apidoc.element.kue.kue.prototype.process">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>process
        <span class="apidocSignatureSpan">( type, n, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function ( type, n, fn ) {
  var self = this;

  if( &#x27;function&#x27; == typeof n ) fn = n, n = 1;

  while( n-- ) {
    var worker = new Worker(this, type).start(fn);
    worker.id  = [ self.id, type, self.workers.length + 1 ].join(&#x27;:&#x27;);
    worker.on(&#x27;error&#x27;, function( err ) {
      self.emit(&#x27;error&#x27;, err);
    });
    worker.on(&#x27;job complete&#x27;, function( job ) {
      // guard against emit after shutdown
      if( self.client ) {
        self.client.incrby(self.client.getKey(&#x27;stats:work-time&#x27;), job.duration, noop);
      }
    });
    // Save worker so we can access it later
    self.workers.push(worker);
  }
  this.setupTimers();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 .save();
```

Kue will check the delayed jobs with a timer, promoting them if the scheduled delay has been exceeded, defaulting to a check of
top 1000 jobs every second.

## Processing Jobs

Processing jobs is simple with Kue. First create a `Queue` instance much like we do for creating jobs, providing us access to redis
 etc, then invoke `queue.<span class="apidocCodeKeywordSpan">process</span>()` with the associated type.
Note that unlike what the name `createQueue` suggests, it currently returns a singleton `Queue` instance. So you can configure and
 use only a single `Queue` object within your node.js process.

In the following example we pass the callback `done` to `email`, When an error occurs we invoke `done(err)` to tell Kue something
 happened, otherwise we invoke `done()` only when the job is complete. If this function responds with an error it will be displayed
 in the UI and the job will be marked as a failure. The error object passed to done, should be of standard type `Error`.

```js
var kue = require(&#x27;kue&#x27;)
, queue = kue.createQueue();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.promote" id="apidoc.element.kue.kue.prototype.promote">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>promote
        <span class="apidocSignatureSpan">( ms, l )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promote = function ( ms, l ) {
  console.warn(&#x27;promote method is deprecated, you don\&#x27;t need to call this anymore. You can safely remove it from your code now.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.setting" id="apidoc.element.kue.kue.prototype.setting">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>setting
        <span class="apidocSignatureSpan">( name, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setting = function ( name, fn ) {
  fn = fn || noop;
  this.client.hget(this.client.getKey(&#x27;settings&#x27;), name, fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.setupTimers" id="apidoc.element.kue.kue.prototype.setupTimers">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>setupTimers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupTimers = function () {
  if( this.warlock === undefined ) {
    this.lockClient = redis.createClient();
    this.warlock    = new Warlock(this.lockClient);
  }
  this.checkJobPromotion(this._options.promotion);
  this.checkActiveJobTtl(this._options.promotion);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     if( self.client ) {
       self.client.incrby(self.client.getKey(&#x27;stats:work-time&#x27;), job.duration, noop);
     }
   });
   // Save worker so we can access it later
   self.workers.push(worker);
 }
 this.<span class="apidocCodeKeywordSpan">setupTimers</span>();
};

/**
* Graceful shutdown
*
* @param {Number} timeout in milliseconds to wait for workers to finish
* @param {String} type specific worker type to shutdown
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.shutdown" id="apidoc.element.kue.kue.prototype.shutdown">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>shutdown
        <span class="apidocSignatureSpan">( timeout, type, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shutdown = function ( timeout, type, fn ) {
  var self = this
    , n    = self.workers.length;
  if( arguments.length === 1 ) {
    fn      = timeout;
    type    = &#x27;&#x27;;
    timeout = null;
  } else if( arguments.length === 2 ) {
    fn   = type;
    type = &#x27;&#x27;;
  }
  var origFn = fn || function() {
    };

  if( this.shuttingDown &#x26;&#x26; type === &#x27;&#x27; ) { // a global shutdown already has been called
    return fn(new Error(&#x27;Shutdown already in progress&#x27;));
  }

  if( type === &#x27;&#x27; ) { // this is a global shutdown call
    this.shuttingDown = true;
  }

  var cleanup = function() {
    if( self.shuttingDown ) {
      self.workers    = [];
      exports.workers = [];
      self.removeAllListeners();
      Queue.singleton = null;
      events.unsubscribe();
      // destroy redis client and pubsub
      redis.reset();
      self.client &#x26;&#x26; self.client.quit();
      self.client = null;
      self.lockClient &#x26;&#x26; self.lockClient.quit();
      self.lockClient = null;
    }
  };

  // Wrap `fn` to only call after all workers finished
  fn = function( err ) {
    if( err ) {
      return origFn(err);
    }
    if( !--n ) {
      cleanup();
      origFn.apply(null, arguments);
    }
  };

  // shut down promoter interval
  if( self.shuttingDown ) {
    if( self.promoter ) {
      clearInterval(self.promoter);
      self.promoter = null;
    }
    if( self.activeJobsTtlTimer ) {
      clearInterval(self.activeJobsTtlTimer);
      self.activeJobsTtlTimer = null;
    }

  }

  if( !self.workers.length ) {
    cleanup();
    origFn();
  } else {
    // Shut down workers 1 by 1
    self.workers.forEach(function( worker ) {
      if( self.shuttingDown || worker.type == type ) {
        worker.shutdown(timeout, fn);
      } else {
        fn &#x26;&#x26; fn();
      }
    });
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


0.9.0 / 2015-05-02
===================

* Upgrade to express 4.x, Closes #537
* Move `job.reprocess` done callback to the last, Closes #387, Closes #385
* Standardize signature of `.<span class="apidocCodeKeywordSpan">shutdown</span>()` callback, Closes #454
* Turn off search indexes by default, Closes #412
* Improve delayed job promotion feature, Closes #533, fixes #312, closes #352
* Use a distributed redis lock to hide job promotion from user, Closes #556
* Deprecate `.promote` and update documentation
* Document Javascript API to query queue state, Closes #455
* Add jobEvents flag to switch off job events for memory optimization, Closes #401
* Add idle event to capture unsuccessful zpop&#x27;s in between of worker get Job, should fix #538
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.state" id="apidoc.element.kue.kue.prototype.state">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>state
        <span class="apidocSignatureSpan">( state, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">state = function ( state, fn ) {
  var self = this;
  this.client.zrange(this.client.getKey(&#x27;jobs:&#x27; + state), 0, -1, function(err,ids){
    var fixedIds = [];
    ids.forEach(function(id){
        fixedIds.push(self.client.stripFIFO(id));
      });
    fn(err,fixedIds);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Completed jobs.
* @param {Function} fn
* @return {Queue} for chaining
* @api public
*/

Queue.prototype.complete = function( fn ) {
 return this.<span class="apidocCodeKeywordSpan">state</span>(&#x27;complete&#x27;, fn);
};

/**
* Failed jobs.
* @param {Function} fn
* @return {Queue} for chaining
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.types" id="apidoc.element.kue.kue.prototype.types">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>types
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">types = function ( fn ) {
  fn = fn || noop;
  this.client.smembers(this.client.getKey(&#x27;job:types&#x27;), fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Serve the index page.
 */

exports.jobs = function( state ) {
  return function( req, res ) {
    queue.<span class="apidocCodeKeywordSpan">types</span>(function( err, types ) {
      res.render(&#x27;job/list&#x27;, {
        state: state, types: types, title: req.app.get(&#x27;title&#x27;)
      });
    });
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.watchStuckJobs" id="apidoc.element.kue.kue.prototype.watchStuckJobs">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>watchStuckJobs
        <span class="apidocSignatureSpan">( ms )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watchStuckJobs = function ( ms ) {
  var client = this.client
    , self   = this
    , ms     = ms || 1000;
  var prefix = this.client.prefix;

  if( this.client.constructor.name == &#x27;Redis&#x27;  || this.client.constructor.name == &#x27;Cluster&#x27;) {
    // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node
    prefix = &#x27;{&#x27; + prefix + &#x27;}&#x27;;
  }
  var script =
        &#x27;local msg = redis.call( &#x22;keys&#x22;, &#x22;&#x27; + prefix + &#x27;:jobs:*:inactive&#x22; )\n\
        local need_fix = 0\n\
        for i,v in ipairs(msg) do\n\
          local queue = redis.call( &#x22;zcard&#x22;, v )\n\
          local jt = string.match(v, &#x22;&#x27; + prefix + &#x27;:jobs:(.*):inactive&#x22;)\n\
          local pending = redis.call( &#x22;LLEN&#x22;, &#x22;&#x27; + prefix + &#x27;:&#x22; .. jt .. &#x22;:jobs&#x22; )\n\
          if queue &#x3e; pending then\n\
            need_fix = need_fix + 1\n\
            for j=1,(queue-pending) do\n\
              redis.call( &#x22;lpush&#x22;, &#x22;&#x27; + prefix + &#x27;:&#x22;..jt..&#x22;:jobs&#x22;, 1 )\n\
            end\n\
          end\n\
        end\n\
        return need_fix&#x27;;
  clearInterval(this.stuck_job_watch);
  client.script(&#x27;LOAD&#x27;, script, function( err, sha ) {
    if( err ) {
      return self.emit(&#x27;error&#x27;, err);
    }
    this.stuck_job_watch = setInterval(function() {
      client.evalsha(sha, 0, function( err, fixes ) {
        if( err ) return clearInterval(this.stuck_job_watch);
      }.bind(this));
    }.bind(this), ms);

  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ```

### Unstable Redis connections

Kue currently uses client side job state management and when redis crashes in the middle of that operations, some stuck jobs or
index inconsistencies will happen. The consequence is that certain number of jobs will be stuck, and be pulled out by worker only
 when new jobs are created, if no more new jobs are created, they stuck forever. So we **strongly** suggest that you run watchdog
 to fix this issue by calling:

```js
queue.<span class="apidocCodeKeywordSpan">watchStuckJobs</span>(interval)
```

`interval` is in milliseconds and defaults to 1000ms

Kue will be refactored to fully atomic job state management from version 1.0 and this will happen by lua scripts and/or BRPOPLPUSH
 combination. You can read more [here](https://github.com/Automattic/kue/issues/130) and [here](https://github.com/Automattic/kue
/issues/38).

## Queue Maintenance
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.workTime" id="apidoc.element.kue.kue.prototype.workTime">
        function <span class="apidocSignatureSpan">kue.kue.prototype.</span>workTime
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">workTime = function ( fn ) {
  this.client.get(this.client.getKey(&#x27;stats:work-time&#x27;), function( err, n ) {
    if( err ) return fn(err);
    fn(null, parseInt(n, 10));
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.kue.prototype.testMode" id="apidoc.module.kue.kue.prototype.testMode">module kue.kue.prototype.testMode</a></h1>




    <h2>
        <a href="#apidoc.element.kue.kue.prototype.testMode.clear" id="apidoc.element.kue.kue.prototype.testMode.clear">
        function <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  jobs.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
queue = require(&#x27;kue&#x27;).createQueue();

before(function() {
  queue.testMode.enter();
});

afterEach(function() {
  queue.testMode.<span class="apidocCodeKeywordSpan">clear</span>();
});

after(function() {
  queue.testMode.exit()
});

it(&#x27;does something cool&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.testMode.enter" id="apidoc.element.kue.kue.prototype.testMode.enter">
        function <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>enter
        <span class="apidocSignatureSpan">(process)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enter = function (process) {
  processQueue         = process || false;
  Job.prototype.save   = testJobSave;
  Job.prototype.update = testJobUpdate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Enable test mode to push all jobs into a `jobs` array. Make assertions against
the jobs in that array to ensure code under test is correctly enqueuing jobs.

```js
queue = require(&#x27;kue&#x27;).createQueue();

before(function() {
  queue.testMode.<span class="apidocCodeKeywordSpan">enter</span>();
});

afterEach(function() {
  queue.testMode.clear();
});

after(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.kue.prototype.testMode.exit" id="apidoc.element.kue.kue.prototype.testMode.exit">
        function <span class="apidocSignatureSpan">kue.kue.prototype.testMode.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
  Job.prototype.save   = originalJobSave;
  Job.prototype.update = originalJobUpdate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var queue = require(&#x27;kue&#x27;).createQueue();

process.once( &#x27;SIGTERM&#x27;, function ( sig ) {
  queue.shutdown( 5000, function(err) {
    console.log( &#x27;Kue shutdown: &#x27;, err||&#x27;&#x27; );
    process.<span class="apidocCodeKeywordSpan">exit</span>( 0 );
  });
});
```

**Note** *that `shutdown` method signature is changed from Kue `&#x3e;=0.9.0` to move the callback function to the last.*

## Error Handling
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.redis" id="apidoc.module.kue.redis">module kue.redis</a></h1>


    <h2>
        <a href="#apidoc.element.kue.redis.client" id="apidoc.element.kue.redis.client">
        function <span class="apidocSignatureSpan">kue.redis.</span>client
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">client = function () {
  return exports._client || (exports._client = exports.createClient());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Number} id
 * @param {String} event
 * @param {Mixed} ...
 * @api private
 */

exports.emit = function( id, event ) {
  var client = redis.<span class="apidocCodeKeywordSpan">client</span>()
    , msg    = JSON.stringify({
        id: id, event: event, args: [].slice.call(arguments, 1)
      });
  client.publish(client.getKey(exports.key), msg, function () {});
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis.configureFactory" id="apidoc.element.kue.redis.configureFactory">
        function <span class="apidocSignatureSpan">kue.redis.</span>configureFactory
        <span class="apidocSignatureSpan">( options, queue )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configureFactory = function ( options, queue ) {
  options.prefix = options.prefix || &#x27;q&#x27;;

  if( typeof options.redis === &#x27;string&#x27; ) {
    // parse the url
    var conn_info = url.parse(options.redis, true<span class="apidocCodeCommentSpan"> /* parse query string */);
    if( conn_info.protocol !== &#x27;redis:&#x27; ) {
      throw new Error(&#x27;kue connection string must use the redis: protocol&#x27;);
    }

    options.redis = {
      port: conn_info.port || 6379,
      host: conn_info.hostname,
      db: (conn_info.pathname ? conn_info.pathname.substr(1) : null) || 0,
      // see https://github.com/mranney/node_redis#rediscreateclient
      options: conn_info.query
    };

    if( conn_info.auth ) {
      options.redis.auth = conn_info.auth.replace(/.*?:/, &#x27;&#x27;);
    }

  }

  options.redis = options.redis || {};

  // guarantee that redis._client has not been populated.
  // may warrant some more testing - i was running into cases where shutdown
  // would call redis.reset but an event would be emitted after the reset
  // which would re-create the client and cache it in the redis module.
  exports.reset();

  /**
   * Create a RedisClient.
   *
   * @return {RedisClient}
   * @api private
   */
</span>  exports.createClient = function() {
    var clientFactoryMethod = options.redis.createClientFactory || exports.createClientFactory;
    var client              = clientFactoryMethod(options);

    client.on(&#x27;error&#x27;, function( err ) {
      queue.emit(&#x27;error&#x27;, err);
    });

    client.prefix           = options.prefix;

    // redefine getKey to use the configured prefix
    client.getKey = function( key ) {
      if( client.constructor.name == &#x27;Redis&#x27;  || client.constructor.name == &#x27;Cluster&#x27;) {
        // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node
        // otherwise multi commands fail, since they use ioredis&#x27;s pipeline.
        return &#x27;{&#x27; + this.prefix + &#x27;}:&#x27; + key;
      }
      return this.prefix + &#x27;:&#x27; + key;
    };

    client.createFIFO = function( id ) {
      //Create an id for the zset to preserve FIFO order
      var idLen = &#x27;&#x27; + id.toString().length;
      var len = 2 - idLen.length;
      while (len--) idLen = &#x27;0&#x27; + idLen;
      return idLen + &#x27;|&#x27; + id;
    };

    // Parse out original ID from zid
    client.stripFIFO = function( zid ) {
      if ( typeof zid === &#x27;string&#x27; ) {
        return +zid.substr(zid.indexOf(&#x27;|&#x27;)+1);
      } else {
        // Sometimes this gets called with an undefined
        // it seems to be OK to have that not resolve to an id
        return zid;
      }
    };

    return client;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.id = [ &#x27;kue&#x27;, require(&#x27;os&#x27;).hostname(), process.pid ].join(&#x27;:&#x27;);
 this._options   = options;
 this.promoter     = null;
 this.workers      = exports.workers;
 this.shuttingDown = false;
 Job.disableSearch = options.disableSearch !== false;
 options.jobEvents !== undefined ? Job.jobEvents = options.jobEvents : &#x27;&#x27;;
 redis.<span class="apidocCodeKeywordSpan">configureFactory</span>(options, this);
 this.client = Worker.client = Job.client = redis.createClient();
}

/**
* Inherit from `EventEmitter.prototype`.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis.createClient" id="apidoc.element.kue.redis.createClient">
        function <span class="apidocSignatureSpan">kue.redis.</span>createClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createClient = function () {
  var clientFactoryMethod = options.redis.createClientFactory || exports.createClientFactory;
  var client              = clientFactoryMethod(options);

  client.on(&#x27;error&#x27;, function( err ) {
    queue.emit(&#x27;error&#x27;, err);
  });

  client.prefix           = options.prefix;

  // redefine getKey to use the configured prefix
  client.getKey = function( key ) {
    if( client.constructor.name == &#x27;Redis&#x27;  || client.constructor.name == &#x27;Cluster&#x27;) {
      // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node
      // otherwise multi commands fail, since they use ioredis&#x27;s pipeline.
      return &#x27;{&#x27; + this.prefix + &#x27;}:&#x27; + key;
    }
    return this.prefix + &#x27;:&#x27; + key;
  };

  client.createFIFO = function( id ) {
    //Create an id for the zset to preserve FIFO order
    var idLen = &#x27;&#x27; + id.toString().length;
    var len = 2 - idLen.length;
    while (len--) idLen = &#x27;0&#x27; + idLen;
    return idLen + &#x27;|&#x27; + id;
  };

  // Parse out original ID from zid
  client.stripFIFO = function( zid ) {
    if ( typeof zid === &#x27;string&#x27; ) {
      return +zid.substr(zid.indexOf(&#x27;|&#x27;)+1);
    } else {
      // Sometimes this gets called with an undefined
      // it seems to be OK to have that not resolve to an id
      return zid;
    }
  };

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var opts = options || {}; // Standard node_redis client options
var masterName = &#x27;mymaster&#x27;;
var sentinel = Sentinel.Sentinel(endpoints);

var q = kue.createQueue({
   redis: {
      createClientFactory: function(){
         return sentinel.<span class="apidocCodeKeywordSpan">createClient</span>(masterName, opts);
      }
   }
});
```

**Note** *that all `&#x3c;0.8.x` client codes should be refactored to pass redis options to `Queue#createQueue` instead of monkey
 patched style overriding of `redis#createClient` or they will be broken from Kue `0.8.x`.*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis.createClientFactory" id="apidoc.element.kue.redis.createClientFactory">
        function <span class="apidocSignatureSpan">kue.redis.</span>createClientFactory
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createClientFactory = function ( options ) {
  var socket = options.redis.socket;
  var port   = !socket ? (options.redis.port || 6379) : null;
  var host   = !socket ? (options.redis.host || &#x27;127.0.0.1&#x27;) : null;
  var db   = !socket ? (options.redis.db || 0) : null;
  var client = redis.createClient(socket || port, host, options.redis.options);
  if( options.redis.auth ) {
    client.auth(options.redis.auth);
  }
  if( db &#x3e;= 0 ){
    client.select(db);
  }
  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis.pubsubClient" id="apidoc.element.kue.redis.pubsubClient">
        function <span class="apidocSignatureSpan">kue.redis.</span>pubsubClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pubsubClient = function () {
  return exports._pubsub || (exports._pubsub = exports.createClient());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @api private
 */

exports.subscribe = function() {
//  if (exports.subscribed) return;
if( exports.subscribeStarted ) return;
var client    = redis.<span class="apidocCodeKeywordSpan">pubsubClient</span>();
client.on(&#x27;message&#x27;, exports.onMessage);
client.subscribe(client.getKey(exports.key),  function() {
  exports.subscribed = true;
  while( exports.callbackQueue.length ) {
    process.nextTick(exports.callbackQueue.shift());
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis.reset" id="apidoc.element.kue.redis.reset">
        function <span class="apidocSignatureSpan">kue.redis.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  exports._client &#x26;&#x26; exports._client.quit();
  exports._pubsub &#x26;&#x26; exports._pubsub.quit();
  exports._client = null;
  exports._pubsub = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if( self.shuttingDown ) {
    self.workers    = [];
    exports.workers = [];
    self.removeAllListeners();
    Queue.singleton = null;
    events.unsubscribe();
    // destroy redis client and pubsub
    redis.<span class="apidocCodeKeywordSpan">reset</span>();
    self.client &#x26;&#x26; self.client.quit();
    self.client = null;
    self.lockClient &#x26;&#x26; self.lockClient.quit();
    self.lockClient = null;
  }
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.redis._pubsub" id="apidoc.module.kue.redis._pubsub">module kue.redis._pubsub</a></h1>






















    <h2>
        <a href="#apidoc.element.kue.redis._pubsub.createFIFO" id="apidoc.element.kue.redis._pubsub.createFIFO">
        function <span class="apidocSignatureSpan">kue.redis._pubsub.</span>createFIFO
        <span class="apidocSignatureSpan">( id )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFIFO = function ( id ) {
  //Create an id for the zset to preserve FIFO order
  var idLen = &#x27;&#x27; + id.toString().length;
  var len = 2 - idLen.length;
  while (len--) idLen = &#x27;0&#x27; + idLen;
  return idLen + &#x27;|&#x27; + id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if( !pending ) return fn(null, ids);
ids.forEach(function( id ) {
  id = redis.client().stripFIFO(id); // turn zid back to regular job id
  exports.get(id, jobType, function( err, job ) {
    if( err ) {
      console.error(err);
    } else {
      jobs[ redis.client().<span class="apidocCodeKeywordSpan">createFIFO</span>(job.id) ] = job;
    }
    --pending || fn(null, &#x27;desc&#x27; == order
      ? map(jobs, ids).reverse()
      : map(jobs, ids));

  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis._pubsub.getKey" id="apidoc.element.kue.redis._pubsub.getKey">
        function <span class="apidocSignatureSpan">kue.redis._pubsub.</span>getKey
        <span class="apidocSignatureSpan">( key )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKey = function ( key ) {
  if( client.constructor.name == &#x27;Redis&#x27;  || client.constructor.name == &#x27;Cluster&#x27;) {
    // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node
    // otherwise multi commands fail, since they use ioredis&#x27;s pipeline.
    return &#x27;{&#x27; + this.prefix + &#x27;}:&#x27; + key;
  }
  return this.prefix + &#x27;:&#x27; + key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if( err ) {
  // Something went wrong and we weren&#x27;t able to set a lock
  self.emit(&#x27;error&#x27;, err);
  return;
}
if( typeof unlock === &#x27;function&#x27; ) {
  // If the lock is set successfully by this process, an unlock function is passed to our callback.
  client.zrangebyscore(client.<span class="apidocCodeKeywordSpan">getKey</span>(&#x27;jobs:delayed&#x27;), 0, Date.now(), &#x27;
LIMIT&#x27;, 0, limit, function( err, ids ) {
    if( err || !ids.length ) return unlock();
    //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1
    var doUnlock = _.after(ids.length, unlock);
    ids.forEach(function( id ) {
      id = client.stripFIFO(id);
      Job.get(id, function( err, job ) {
        if( err ) return doUnlock();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.redis._pubsub.stripFIFO" id="apidoc.element.kue.redis._pubsub.stripFIFO">
        function <span class="apidocSignatureSpan">kue.redis._pubsub.</span>stripFIFO
        <span class="apidocSignatureSpan">( zid )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripFIFO = function ( zid ) {
  if ( typeof zid === &#x27;string&#x27; ) {
    return +zid.substr(zid.indexOf(&#x27;|&#x27;)+1);
  } else {
    // Sometimes this gets called with an undefined
    // it seems to be OK to have that not resolve to an id
    return zid;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if( typeof unlock === &#x27;function&#x27; ) {
// If the lock is set successfully by this process, an unlock function is passed to our callback.
client.zrangebyscore(client.getKey(&#x27;jobs:delayed&#x27;), 0, Date.now(), &#x27;LIMIT&#x27;, 0, limit, function( err, ids ) {
  if( err || !ids.length ) return unlock();
  //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1
  var doUnlock = _.after(ids.length, unlock);
  ids.forEach(function( id ) {
    id = client.<span class="apidocCodeKeywordSpan">stripFIFO</span>(id);
    Job.get(id, function( err, job ) {
      if( err ) return doUnlock();
      events.emit(id, &#x27;promotion&#x27;);
      job.inactive(doUnlock);
    });
  });
});
...</pre></li>
    </ul>


























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.worker" id="apidoc.module.kue.worker">module kue.worker</a></h1>


    <h2>
        <a href="#apidoc.element.kue.worker.worker" id="apidoc.element.kue.worker.worker">
        function <span class="apidocSignatureSpan">kue.</span>worker
        <span class="apidocSignatureSpan">( queue, type )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Worker( queue, type ) {
  this.queue   = queue;
  this.type    = type;
  this.client  = Worker.client || (Worker.client = redis.createClient());
  this.running = true;
  this.job     = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kue.worker.prototype" id="apidoc.module.kue.worker.prototype">module kue.worker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kue.worker.prototype.emitJobEvent" id="apidoc.element.kue.worker.prototype.emitJobEvent">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>emitJobEvent
        <span class="apidocSignatureSpan">( event, job, arg1, arg2 )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitJobEvent = function ( event, job, arg1, arg2 ) {
  if( this.cleaned_up ) return;
  events.emit(job.id, event, arg1, arg2);
  this.emit(&#x27;job &#x27; + event, job);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

Worker.prototype.failed = function( job, theErr, fn ) {
  var self = this;
  job.failedAttempt( theErr, function( err, hasAttempts, attempt ) {
    if( err ) return self.error(err, job);
    if( hasAttempts ) {
      self.<span class="apidocCodeKeywordSpan">emitJobEvent</span>( &#x27;failed attempt&#x27;, job, theErr.message || theErr.toString
(), attempt );
    } else {
      self.emitJobEvent( &#x27;failed&#x27;, job, theErr.message || theErr.toString() );
    }
    fn &#x26;&#x26; self.start(fn);
  });
  return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.error" id="apidoc.element.kue.worker.prototype.error">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>error
        <span class="apidocSignatureSpan">( err, job )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function ( err, job ) {
  this.emit(&#x27;error&#x27;, err, job);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



2. Binding to `uncaughtException` and gracefully shutting down the Kue, however this is not a recommended error handling idiom in
 javascript since you are losing the error context.

```js
process.once( &#x27;uncaughtException&#x27;, function(err){
  console.<span class="apidocCodeKeywordSpan">error</span>( &#x27;Something bad happened: &#x27;, err );
  queue.shutdown( 1000, function(err2){
    console.error( &#x27;Kue shutdown result: &#x27;, err2 || &#x27;OK&#x27; );
    process.exit( 0 );
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.failed" id="apidoc.element.kue.worker.prototype.failed">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>failed
        <span class="apidocSignatureSpan">( job, theErr, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failed = function ( job, theErr, fn ) {
  var self = this;
  job.failedAttempt( theErr, function( err, hasAttempts, attempt ) {
    if( err ) return self.error(err, job);
    if( hasAttempts ) {
      self.emitJobEvent( &#x27;failed attempt&#x27;, job, theErr.message || theErr.toString(), attempt );
    } else {
      self.emitJobEvent( &#x27;failed&#x27;, job, theErr.message || theErr.toString() );
    }
    fn &#x26;&#x26; self.start(fn);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Job.prototype.attempts = function( n ) {
this._max_attempts = n;
return this;
};


Job.prototype.failedAttempt = function( theErr, fn ) {
this.error(theErr).<span class="apidocCodeKeywordSpan">failed</span>(function() {
  this.attempt(function( error, remaining, attempts/*, max*/ ) {
    if( error ) {
      this.emit( &#x27;error&#x27;, error );
      return fn &#x26;&#x26; fn( error );
    }
    if( remaining &#x3e; 0 ) {
      this.reattempt(attempts, function( err ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.getJob" id="apidoc.element.kue.worker.prototype.getJob">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>getJob
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJob = function ( fn ) {
  var self = this;
  if( !self.running ) {
    return fn(&#x27;Already Shutdown&#x27;);
  }
  // alloc a client for this job type
  var client = clients[ self.type ] || (clients[ self.type ] = redis.createClient());
  // BLPOP indicates we have a new inactive job to process
  client.blpop(client.getKey(self.type + &#x27;:jobs&#x27;), 0, function( err ) {
    if( err || !self.running ) {
      if( self.client &#x26;&#x26; self.client.connected &#x26;&#x26; !self.client.closing ) {
        self.client.lpush(self.client.getKey(self.type + &#x27;:jobs&#x27;), 1, noop);
      }
      return fn(err);		// SAE: Added to avoid crashing redis on zpop
    }
    // Set job to a temp value so shutdown() knows to wait
    self.job = true;
    self.zpop(self.client.getKey(&#x27;jobs:&#x27; + self.type + &#x27;:inactive&#x27;), function( err, id ) {
      if( err || !id ) {
        self.idle();
        return fn(err /*|| &#x22;No job to pop!&#x22;*/);
      }
      Job.get(id, fn);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if( this.job &#x26;&#x26; this.job.id &#x26;&#x26; this.job.id === id ) {
    //this.start(fn);
    this.failed( this.job, { error: true, message: &#x27;TTL exceeded&#x27; }, fn );
    events.emit(id, &#x27;ttl exceeded ack&#x27;);
  }
}.bind( this ));

self.<span class="apidocCodeKeywordSpan">getJob</span>(function( err, job ) {
  if( err ) self.error(err, job);
  if( !job || err ) return process.nextTick(function() {
    self.start(fn);
  });
  self.process(job, fn);
});
return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.idle" id="apidoc.element.kue.worker.prototype.idle">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>idle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idle = function () {
  this.job = null;
  this.emit(&#x27;idle&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} fn
 * @return {Worker} for chaining
 * @api private
 */

Worker.prototype.start = function( fn ) {
var self = this;
self.<span class="apidocCodeKeywordSpan">idle</span>();
if( !self.running ) return;
this.queue.removeAllListeners(&#x27;job ttl exceeded&#x27;);

/*
 listen if current job ttl received,
 so that this worker can fail current stuck job and continue,
 in case user&#x27;s process callback is stuck and done is not called in time
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.process" id="apidoc.element.kue.worker.prototype.process">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>process
        <span class="apidocSignatureSpan">( job, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function ( job, fn ) {
  var self  = this
    , start = new Date();

  this.job = job;
  job.set( &#x27;started_at&#x27;, job.started_at = start.getTime() );
  job.set( &#x27;workerId&#x27;, job.workerId = this.id );
<span class="apidocCodeCommentSpan">  /*
  store job.id around given done to the caller,
  so that we can later match against it when done is called
   */
</span>  var createDoneCallback = function( jobId ) {
    return function( err, result ) {
      if( self.drop_user_callbacks ) {
        //console.warn( &#x27;Worker started to shutdown, ignoring execution of done callback&#x27; );
        //job.log( &#x27;Worker started to shutdown, ignoring execution of done callback&#x27; );
        return;
      }
      /*
      if no job in hand, or the current job in hand
      doesn&#x27;t match called done callback&#x27;s jobId
      then ignore running callers done.
       */
      if( self.job === null || self.job &#x26;&#x26; self.job.id &#x26;&#x26; self.job.id !== jobId ) {
        //console.warn( &#x27;This job has already been finished, ignoring execution of done callback&#x27; );
        //job.log( &#x27;This job has already been finished, ignoring execution of done callback&#x27; );
        return;
      }
      if( err ) {
        return self.failed(job, err, fn);
      }
      job.set(&#x27;duration&#x27;, job.duration = new Date - start);
      if( result ) {
        try {
          job.result = result;
          job.set(&#x27;result&#x27;, JSON.stringify(result), noop);
        } catch(e) {
          job.set(&#x27;result&#x27;, JSON.stringify({ error: true, message: &#x27;Invalid JSON Result: &#x22;&#x27; + result + &#x27;&#x22;&#x27; }), noop);
        }
      }
      job.complete(function() {
        job.attempt(function() {
          if( job.removeOnComplete() ) {
            job.remove();
          }
          self.emitJobEvent(&#x27;complete&#x27;, job, result);
          self.start(fn);
        });
      }.bind(this));
    };
  };

  var doneCallback = createDoneCallback( job.id );

  var workerCtx    = {
    /**
     * @author behrad
     * @pause: let the processor to tell worker not to continue processing new jobs
     */
    pause: function( timeout, fn ) {
      if( arguments.length === 1 ) {
        fn      = timeout;
        timeout = 5000;
      }
      self.queue.shutdown(Number(timeout), self.type, fn);
    },
    /**
     * @author behrad
     * @pause: let the processor to trigger restart for they job processing
     */
    resume: function() {
      if( self.resume() ) {
        self.start(fn);
      }
    },
    shutdown: function() {
      self.shutdown();
    }
  };

  job.active(function() {
    self.emitJobEvent(&#x27;start&#x27;, job, job.type);
    if( fn.length === 2 ) { // user provided a two argument function, doesn&#x27;t need workerCtx
      fn(job, doneCallback);
    } else { // user wants workerCtx parameter, make done callback the last
      fn(job, workerCtx, doneCallback);
    }
  }.bind(this));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 .save();
```

Kue will check the delayed jobs with a timer, promoting them if the scheduled delay has been exceeded, defaulting to a check of
top 1000 jobs every second.

## Processing Jobs

Processing jobs is simple with Kue. First create a `Queue` instance much like we do for creating jobs, providing us access to redis
 etc, then invoke `queue.<span class="apidocCodeKeywordSpan">process</span>()` with the associated type.
Note that unlike what the name `createQueue` suggests, it currently returns a singleton `Queue` instance. So you can configure and
 use only a single `Queue` object within your node.js process.

In the following example we pass the callback `done` to `email`, When an error occurs we invoke `done(err)` to tell Kue something
 happened, otherwise we invoke `done()` only when the job is complete. If this function responds with an error it will be displayed
 in the UI and the job will be marked as a failure. The error object passed to done, should be of standard type `Error`.

```js
var kue = require(&#x27;kue&#x27;)
, queue = kue.createQueue();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.resume" id="apidoc.element.kue.worker.prototype.resume">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  if( this.running ) return false;
  this.cleaned_up          = false;
  this.drop_user_callbacks = false;
  this.running             = true;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Workers can temporary pause and resume their activity. It is, after calling `pause` they will receive no jobs in their process callback
 until `resume` is called. `pause` function gracefully shutdowns this worker, and uses the same internal functionality as `shutdown
` method in [Graceful Shutdown](#graceful-shutdown).

```js
queue.process(&#x27;email&#x27;, function(job, ctx, done){
  ctx.pause( 5000, function(err){
    console.log(&#x22;Worker is paused... &#x22;);
    setTimeout( function(){ ctx.<span class="apidocCodeKeywordSpan">resume</span>(); }, 10000 );
  });
});
```

**Note** *that the `ctx` parameter from Kue `&#x3e;=0.9.0` is the second argument of the process callback function and `done` is
 idiomatically always the last*

**Note** *that `pause` method signature is changed from Kue `&#x3e;=0.9.0` to move the callback function to the last.*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.shutdown" id="apidoc.element.kue.worker.prototype.shutdown">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>shutdown
        <span class="apidocSignatureSpan">( timeout, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shutdown = function ( timeout, fn ) {
  var self = this, shutdownTimer = null;
  if( arguments.length === 1 ) {
    fn      = timeout;
    timeout = null;
  }

  // Wrap `fn` so we don&#x27;t pass `job` to it
  var _fn = function( job ) {
    if( job &#x26;&#x26; self.job &#x26;&#x26; job.id != self.job.id ) {
      return; // simply ignore older job events currently being received until the right one comes...
    }
    shutdownTimer &#x26;&#x26; clearTimeout(shutdownTimer);
    self.removeAllListeners();
    self.job        = null;
    //Safeyly kill any blpop&#x27;s that are waiting.
    (self.type in clients) &#x26;&#x26; clients[ self.type ].quit();
    delete clients[ self.type ];
    self.cleaned_up = true;
    //fix half-blob job fetches if any
    self.client.lpush(self.client.getKey(self.type + &#x27;:jobs&#x27;), 1, fn || noop);
  };

  if( !this.running ) return _fn();
  this.running = false;

  // As soon as we&#x27;re free, signal that we&#x27;re done
  if( !this.job ) {
    return _fn();
  }
  this.on(&#x27;idle&#x27;, _fn);
  this.on(&#x27;job complete&#x27;, _fn);
  this.on(&#x27;job failed&#x27;, _fn);
  this.on(&#x27;job failed attempt&#x27;, _fn);

  if( timeout ) {
    shutdownTimer = setTimeout(function() {
      // shutdown timeout reached...
      if( self.job ) {
        self.drop_user_callbacks = true;
        self.removeAllListeners();
        if( self.job === true ) {
          self.once(&#x27;idle&#x27;, _fn);
        } else {
          // a job is running, fail it and call _fn when failed
          self.once(&#x27;job failed&#x27;, _fn);
          self.once(&#x27;job failed attempt&#x27;, _fn);
          self.failed(self.job, { error: true, message: &#x27;Shutdown&#x27; });
        }
      } else {
        // no job running, just finish immediately
        _fn();
      }
    }.bind(this), timeout);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


0.9.0 / 2015-05-02
===================

* Upgrade to express 4.x, Closes #537
* Move `job.reprocess` done callback to the last, Closes #387, Closes #385
* Standardize signature of `.<span class="apidocCodeKeywordSpan">shutdown</span>()` callback, Closes #454
* Turn off search indexes by default, Closes #412
* Improve delayed job promotion feature, Closes #533, fixes #312, closes #352
* Use a distributed redis lock to hide job promotion from user, Closes #556
* Deprecate `.promote` and update documentation
* Document Javascript API to query queue state, Closes #455
* Add jobEvents flag to switch off job events for memory optimization, Closes #401
* Add idle event to capture unsuccessful zpop&#x27;s in between of worker get Job, should fix #538
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.start" id="apidoc.element.kue.worker.prototype.start">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>start
        <span class="apidocSignatureSpan">( fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function ( fn ) {
  var self = this;
  self.idle();
  if( !self.running ) return;
  this.queue.removeAllListeners(&#x27;job ttl exceeded&#x27;);

<span class="apidocCodeCommentSpan">  /*
   listen if current job ttl received,
   so that this worker can fail current stuck job and continue,
   in case user&#x27;s process callback is stuck and done is not called in time
   */
</span>  this.queue.on( &#x27;job ttl exceeded&#x27;, function( id ) {
    if( this.job &#x26;&#x26; this.job.id &#x26;&#x26; this.job.id === id ) {
      //this.start(fn);
      this.failed( this.job, { error: true, message: &#x27;TTL exceeded&#x27; }, fn );
      events.emit(id, &#x27;ttl exceeded ack&#x27;);
    }
  }.bind( this ));

  self.getJob(function( err, job ) {
    if( err ) self.error(err, job);
    if( !job || err ) return process.nextTick(function() {
      self.start(fn);
    });
    self.process(job, fn);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Queue.prototype.process = function( type, n, fn ) {
var self = this;

if( &#x27;function&#x27; == typeof n ) fn = n, n = 1;

while( n-- ) {
  var worker = new Worker(this, type).<span class="apidocCodeKeywordSpan">start</span>(fn);
  worker.id  = [ self.id, type, self.workers.length + 1 ].join(&#x27;:&#x27;);
  worker.on(&#x27;error&#x27;, function( err ) {
    self.emit(&#x27;error&#x27;, err);
  });
  worker.on(&#x27;job complete&#x27;, function( job ) {
    // guard against emit after shutdown
    if( self.client ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kue.worker.prototype.zpop" id="apidoc.element.kue.worker.prototype.zpop">
        function <span class="apidocSignatureSpan">kue.worker.prototype.</span>zpop
        <span class="apidocSignatureSpan">( key, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zpop = function ( key, fn ) {
  this.client
    .multi()
    .zrange(key, 0, 0)
    .zremrangebyrank(key, 0, 0)
    .exec(function( err, res ) {
      if( err || !res || !res[ 0 ] || !res[ 0 ].length ) return fn(err);
      var id = res[ 0 ][ 0 ] || res[ 0 ][ 1 ][ 0 ];
      fn(null, this.client.stripFIFO(id));
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if( self.client &#x26;&#x26; self.client.connected &#x26;&#x26; !self.client.closing ) {
      self.client.lpush(self.client.getKey(self.type + &#x27;:jobs&#x27;), 1, noop);
    }
    return fn(err);		// SAE: Added to avoid crashing redis on zpop
  }
  // Set job to a temp value so shutdown() knows to wait
  self.job = true;
  self.<span class="apidocCodeKeywordSpan">zpop</span>(self.client.getKey(&#x27;jobs:&#x27; + self.type + &#x27;:inactive&#x27;),
function( err, id ) {
    if( err || !id ) {
      self.idle();
      return fn(err /*|| &#x22;No job to pop!&#x22;*/);
    }
    Job.get(id, fn);
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
